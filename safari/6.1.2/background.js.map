{"version":3,"file":"background.js","mappings":"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","sources":["webpack:///./maze-utils/src/background-request-proxy.ts","webpack:///./maze-utils/src/browserApi.ts","webpack:///./maze-utils/src/cleanup.ts","webpack:///./maze-utils/src/config.ts","webpack:///./maze-utils/src/dom.ts","webpack:///./maze-utils/src/formating.ts","webpack:///./maze-utils/src/hash.ts","webpack:///./maze-utils/src/index.ts","webpack:///./maze-utils/src/setup.ts","webpack:///./maze-utils/src/tab-updates.ts","webpack:///./src/background.ts","webpack:///./src/config.ts","webpack:///./src/types.ts","webpack:///./src/utils.ts","webpack:///./src/utils/crossExtension.ts","webpack:///./src/utils/logger.ts","webpack:///./src/utils/requests.ts","webpack:///./src/utils/skipRule.type.ts","webpack:///./node_modules/webext-polyfill-kinda/index.js","webpack:///./node_modules/webext-patterns/index.js","webpack:///./node_modules/webext-content-scripts/index.js","webpack:///./node_modules/content-scripts-register-polyfill/ponyfill.js","webpack:///./node_modules/content-scripts-register-polyfill/index.js","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"sourcesContent":["import { isFirefoxOrSafari, objectToURI } from \".\";\nimport { isSafari } from \"./config\";\nimport { isBodyGarbage } from \"./formating\";\nimport { getHash } from \"./hash\";\n\nexport interface FetchResponse {\n    responseText: string;\n    headers: Record<string, string> | null;\n    status: number;\n    ok: boolean;\n}\n\nexport interface FetchResponseBinary {\n    responseBinary: Blob | number[];\n    headers: Record<string, string> | null;\n    status: number;\n    ok: boolean;\n}\n\n/**\n * Sends a request to the specified url\n *\n * @param type The request type \"GET\", \"POST\", etc.\n * @param address The address to add to the SponsorBlock server address\n * @param callback\n */\nexport async function sendRealRequestToCustomServer(type: string, url: string,\n        data: Record<string, unknown> | null = {}, headers: Record<string, unknown> = {}) {\n    // If GET, convert JSON to parameters\n    if (type.toLowerCase() === \"get\") {\n        url = objectToURI(url, data, true);\n\n        data = null;\n    }\n\n    const response = await fetch(url, {\n        method: type,\n        headers: {\n            'Content-Type': 'application/json',\n            ...(headers || {})\n        },\n        redirect: 'follow',\n        body: data ? JSON.stringify(data) : null\n    });\n\n    return response;\n}\n\n/**\n * Checks whether the value is safe to send using .postMessage()\n *\n * @param value The value to check\n * @returns true if the value is serializable, false otherwise\n */\nexport function isSerializable(value: unknown): boolean {\n    try {\n        window.structuredClone(value);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\ninterface MaybeError {\n    toString?: () => string,\n}\n\n/**\n * Ensures the value is serializable by converting to a string if it's not\n *\n * Useful for sending errors cause you never really know what \"error\" you may get with JS\n *\n * @param value The value to check\n * @returns Unmodified value if serializable, stringified version otherwise\n */\nexport function serializeOrStringify<T>(value: T & MaybeError): T | string {\n    return isSerializable(value)\n        ? value\n        : (\n            \"toString\" in value && typeof value.toString === 'function'\n            ? value.toString()\n            : String(value)\n        );\n}\n\nexport function setupBackgroundRequestProxy() {\n    chrome.runtime.onMessage.addListener((request, sender, callback) => {\n        if (request.message === \"sendRequest\") {\n            sendRealRequestToCustomServer(request.type, request.url, request.data, request.headers).then(async (response) => {\n                const buffer = request.binary \n                    ? ((isFirefoxOrSafari() && !isSafari())\n                        ? await response.blob()\n                        : Array.from(new Uint8Array(await response.arrayBuffer())))\n                    : null;\n\n                callback({\n                    responseText: !request.binary ? await response.text() : \"\",\n                    responseBinary: buffer,\n                    headers: (request.returnHeaders && response.headers)\n                            ? [...response.headers.entries()].reduce((acc, [key, value]) => {\n                                acc[key] = value;\n                                return acc;\n                            }\n                        , {})\n                        : null,\n                    status: response.status,\n                    ok: response.ok\n                });\n            }).catch(error => {\n                console.error(\"Proxied request failed:\", error)\n                callback({\n                    error: serializeOrStringify(error),\n                });\n            });\n\n            return true;\n        }\n\n        if (request.message === \"getHash\") {\n            getHash(request.value, request.times).then(callback).catch((e) => {\n                console.error(\"Hash request failed:\", e)\n                callback({\n                    error: serializeOrStringify(e),\n                });\n            });\n\n            return true;\n        }\n\n        return false;\n    });\n}\n\nexport function sendRequestToCustomServer(type: string, url: string, data = {}, headers = {}): Promise<FetchResponse> {\n    return new Promise((resolve, reject) => {\n        // Ask the background script to do the work\n        chrome.runtime.sendMessage({\n            message: \"sendRequest\",\n            type,\n            url,\n            data,\n            headers\n        }, (response) => {\n            if (\"error\" in response) {\n                reject(response.error);\n            } else {\n                resolve(response);\n            }\n        });\n    });\n}\n\nexport function sendBinaryRequestToCustomServer(type: string, url: string, data = {}, headers = {}): Promise<FetchResponseBinary> {\n    return new Promise((resolve, reject) => {\n        // Ask the background script to do the work\n        chrome.runtime.sendMessage({\n            message: \"sendRequest\",\n            type,\n            url,\n            data,\n            headers,\n            binary: true,\n            returnHeaders: true\n        }, (response) => {\n            if (\"error\" in response) {\n                reject(response.error);\n            } else {\n                resolve(response);\n            }\n        });\n    });\n}\n\n/**\n * Formats and `console.warn`s the given request\n *\n * Use this to log failed requests.\n *\n * @param request The request to log\n * @param prefix Extension prefix, such as \"SB\" or \"CB\". Brackets will be added automatically\n * @param requestDescription A string describing what the failed request was, such as \"segment skip log\", which would produce \"Server responded ... to a segment skip log request\"\n */\nexport function logRequest(request: FetchResponse | FetchResponseBinary, prefix: string, requestDescription: string) {\n    const body = (\"responseText\" in request && !isBodyGarbage(request.responseText)) ? `: ${request.responseText}` : \"\"\n    console.warn(`[${prefix}] Server responded with code ${request.status} to a ${requestDescription} request${body}`);\n}\n","export const chromeP = typeof(browser) === \"undefined\" ? (typeof(chrome) !== \"undefined\" ? chrome : null as unknown as typeof chrome) : browser;","import { chromeP } from \"./browserApi\";\n\nconst cleanupListeners: (() => void)[] = [];\nexport function addCleanupListener(listener: () => void) {\n    cleanupListeners.push(listener);\n}\n\nexport function setupCleanupListener() {\n    const source = getCleanupId();\n\n    const started = performance.now();\n    window.postMessage({\n        source,\n        message: getCleanupStartMessage()\n    });\n\n    window.addEventListener(\"message\", (message) => {\n        if (message.data?.source \n                && message.data.source === source\n                && message.data.message === getCleanupStartMessage()\n                && performance.now() - started > 5000) {\n\n            for (const listener of cleanupListeners) {\n                listener();\n            }\n        }\n    });\n}\n\nexport function getCleanupId() {\n    return `${chrome.runtime.id}-cleanup`;\n}\n\nexport function getCleanupStartMessage() {\n    return \"cleanup-start\"\n}\n\nexport interface InjectedScript {\n    matches?: string[];\n    js?: string[];\n    css?: string[];\n}\n\nexport async function injectUpdatedScripts(extraScripts: InjectedScript[] = [], ignoreNormalScipts = false) {\n    const scripts = ignoreNormalScipts ? extraScripts : extraScripts.concat(chrome.runtime.getManifest().content_scripts || []);\n    if (\"scripting\" in chrome) {\n        for (const cs of scripts) {\n            for (const tab of await chromeP.tabs.query({url: cs.matches})) {\n                if (cs.css && cs.css.length > 0) {\n                    await chromeP.scripting.insertCSS({\n                        target: {tabId: tab.id!},\n                        files: cs.css || [],\n                    })\n                }\n    \n                await chromeP.scripting.executeScript({\n                    target: {tabId: tab.id!},\n                    files: cs.js || [],\n                    \n                    world: cs[\"world\"] || \"ISOLATED\"\n                })\n            }\n        }\n    } else {\n        chrome.windows.getAll({\n            populate: true\n        }, (windows) => {\n            for (const window of windows) {\n                if (window.tabs) {\n                    for (const tab of window.tabs) {\n                        for (const script of scripts) {\n                            if (tab.url && script.matches?.some?.((match) => \n                                    tab.url!.match(match\n                                            .replace(/\\//g, \"\\\\/\")\n                                            .replace(/\\./g, \"\\\\.\")\n                                            .replace(/\\*/g, \".*\")))) {\n                                if (script.js) {\n                                    for (const file of script.js) {\n                                        void chrome.tabs.executeScript(tab.id!, {\n                                            file\n                                        });\n                                    }\n                                }\n    \n                                if (script.css) {\n                                    for (const file of script.css) {\n                                        void chrome.tabs.insertCSS(tab.id!, {\n                                            file\n                                        });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n}","import { isFirefoxOrSafari } from \".\";\n\nexport interface SyncStorage {\n    invidiousInstances: string[];\n}\n\nexport interface LocalStorage {\n    navigationApiAvailable: boolean;\n}\n\ninterface StorageObjects<T, U> {\n    sync: T;\n    local: U;\n}\n\nexport type StorageChangesObject = { [key: string]: chrome.storage.StorageChange };\n\nexport type Keybind = {\n    key: string | null;\n    code?: string | null;\n    ctrl?: boolean | null;\n    alt?: boolean | null;\n    shift?: boolean | null;\n}\n\nexport class ProtoConfig<T extends SyncStorage, U extends LocalStorage> {\n    configLocalListeners: Array<(changes: StorageChangesObject) => unknown> = [];\n    configSyncListeners: Array<(changes: StorageChangesObject) => unknown> = [];\n    syncDefaults: T;\n    localDefaults: U;\n    cachedSyncConfig: T | null = null;\n    cachedLocalStorage: U | null = null;\n    config: T | null = null;\n    local: U | null = null;\n    inDeArrow = false;\n\n    constructor (syncDefaults: T, localDefaults: U,\n            migrateOldSyncFormats: (config: T, local?: U) => void, inDeArrow = false) {\n        this.syncDefaults = syncDefaults;\n        this.localDefaults = localDefaults;\n        this.inDeArrow = inDeArrow;\n\n        void this.setupConfig(migrateOldSyncFormats).then((result) => {\n            this.config = result?.sync;\n            this.local = result?.local;\n        });\n    }\n\n    configProxy(): StorageObjects<T, U> {\n        chrome.storage.onChanged.addListener((changes: {[key: string]: chrome.storage.StorageChange}, areaName) => {\n            if (areaName === \"sync\") {\n                for (const key in changes) {\n                    this.cachedSyncConfig![key] = changes[key].newValue;\n                }\n    \n                for (const callback of this.configSyncListeners) {\n                    callback(changes);\n                }\n            } else if (areaName === \"local\") {\n                for (const key in changes) {\n                    this.cachedLocalStorage![key] = changes[key].newValue;\n                }\n    \n                for (const callback of this.configLocalListeners) {\n                    callback(changes);\n                }\n            }\n        });\n\n        let lastSet = 0;\n        const nextToUpdate: Set<string> = new Set();\n        let activeTimeout: NodeJS.Timeout | null = null;\n\n        const self = this;\n        const syncHandler: ProxyHandler<SyncStorage> = {\n            set<K extends keyof SyncStorage>(obj: SyncStorage, prop: K, value: SyncStorage[K]) {\n                self.cachedSyncConfig![prop] = value;\n\n                if (Date.now() - lastSet < 100) {\n                    nextToUpdate.add(prop);\n                    if (!activeTimeout) {\n                        const delayUpdate = () => {\n                            const items = [...nextToUpdate];\n                            nextToUpdate.clear();\n\n                            void chrome.storage.sync.set(items.map((v) => [v, self.cachedSyncConfig![v]]).reduce((acc, [k, v]) => {\n                                acc[k] = v;\n                                return acc;\n                            }, {}));\n\n                            activeTimeout = null;\n                        }\n\n                        activeTimeout = setTimeout(delayUpdate, 20);\n                    }\n\n                    return true;\n                }\n    \n                void chrome.storage.sync.set({\n                    [prop]: value\n                });\n\n                lastSet = Date.now();\n    \n                return true;\n            },\n    \n            get<K extends keyof SyncStorage>(obj: SyncStorage, prop: K): SyncStorage[K] {\n                const data = self.cachedSyncConfig![prop];\n    \n                return obj[prop] || data;\n            },\n    \n            deleteProperty(obj: SyncStorage, prop: keyof SyncStorage) {\n                void chrome.storage.sync.remove(<string> prop);\n    \n                return true;\n            }\n    \n        };\n    \n        const localHandler: ProxyHandler<LocalStorage> = {\n            set<K extends keyof LocalStorage>(obj: LocalStorage, prop: K, value: LocalStorage[K]) {\n                self.cachedLocalStorage![prop] = value;\n    \n                void chrome.storage.local.set({\n                    [prop]: value\n                });\n    \n                return true;\n            },\n    \n            get<K extends keyof LocalStorage>(obj: LocalStorage, prop: K): LocalStorage[K] {\n                const data = self.cachedLocalStorage![prop];\n    \n                return obj[prop] || data;\n            },\n    \n            deleteProperty(obj: LocalStorage, prop: keyof LocalStorage) {\n                void chrome.storage.local.remove(<string> prop);\n    \n                return true;\n            }\n    \n        };\n    \n        return {\n            sync: new Proxy<T>({ handler: syncHandler } as unknown as T, syncHandler),\n            local: new Proxy<U>({ handler: localHandler } as unknown as U, localHandler)\n        };\n    }\n    \n    forceSyncUpdate(prop: string): void {\n        const value = this.cachedSyncConfig![prop];\n        void chrome.storage.sync.set({\n            [prop]: value\n        });\n    }\n    \n    forceLocalUpdate(prop: string): void {\n        const value = this.cachedLocalStorage![prop];\n\n        void chrome.storage.local.set({\n            [prop]: value\n        }, () => {\n            const error = chrome.runtime.lastError;\n            if (error && prop !== \"navigationApiAvailable\") {\n                alert(`SponsorBlock/DeArrow: ${chrome.i18n.getMessage(\"storageFull\")}\\n\\n${error}`);\n            }\n        });\n    }\n    \n    async fetchConfig(): Promise<void> {\n        await Promise.all([new Promise<void>((resolve) => {\n            chrome.storage.sync.get(null, (items) => {\n                this.cachedSyncConfig = <T> <unknown> items;\n\n                if (this.cachedSyncConfig === undefined) {\n                    this.cachedSyncConfig = {} as T;\n\n                    if (this.inDeArrow \n                            || window.location.href.includes(\"options.html\")) {\n                        alert(`${chrome.i18n.getMessage(\"syncDisabledWarning\")}${\n                            this.inDeArrow ? `\\n\\n${chrome.i18n.getMessage(\"syncDisabledWarningDeArrow\")}` : ``}${\n                            isFirefoxOrSafari() && !isSafari() ? `\\n\\n${chrome.i18n.getMessage(\"syncDisabledFirefoxSuggestions\")}` : ``}`);\n                    }\n                }\n\n                resolve();\n            });\n        }), new Promise<void>((resolve) => {\n            chrome.storage.local.get(null, (items) => {\n                this.cachedLocalStorage = <U> <unknown> (items ?? {});\n                resolve();\n            });\n        })]);\n    }\n    \n    async setupConfig(migrateOldSyncFormats: (config: T, local?: U) => void): Promise<StorageObjects<T, U>> {\n        if (typeof(chrome) === \"undefined\") return null as unknown as StorageObjects<T, U>;\n    \n        await this.fetchConfig();\n        this.addDefaults();\n        const result = this.configProxy();\n        migrateOldSyncFormats(result.sync, result.local);\n    \n        return result;\n    }\n    \n    // Add defaults\n    addDefaults() {\n        for (const key in this.syncDefaults) {\n            if(!Object.prototype.hasOwnProperty.call(this.cachedSyncConfig, key)) {\n                this.cachedSyncConfig![key] = this.syncDefaults[key];\n            } else if (key === \"barTypes\") {\n                for (const key2 in this.syncDefaults[key]) {\n                    if(!Object.prototype.hasOwnProperty.call(this.cachedSyncConfig![key], key2)) {\n                        this.cachedSyncConfig![key][key2] = this.syncDefaults[key][key2];\n                    }\n                }\n            }\n        }\n    \n        for (const key in this.localDefaults) {\n            if(!Object.prototype.hasOwnProperty.call(this.cachedLocalStorage, key)) {\n                this.cachedLocalStorage![key] = this.localDefaults[key];\n            }\n        }\n    }\n\n    isReady(): boolean {\n        return this.config !== null;\n    }\n}\n\nexport function isSafari(): boolean {\n    return typeof(navigator) !== \"undefined\" && navigator.vendor === \"Apple Computer, Inc.\";\n}\n\nexport function keybindEquals(first: Keybind, second: Keybind): boolean {\n    if (first == null || second == null ||\n            Boolean(first.alt) != Boolean(second.alt) || Boolean(first.ctrl) != Boolean(second.ctrl) || Boolean(first.shift) != Boolean(second.shift) ||\n            first.key == null && first.code == null || second.key == null && second.code == null)\n        return false;\n    if (first.code != null && second.code != null)\n        return first.code === second.code;\n    if (first.key != null && second.key != null)\n        return first.key.toUpperCase() === second.key.toUpperCase();\n    return false;\n}\n\nexport function formatKey(key: string): string {\n    if (key == null)\n        return \"\";\n    else if (key == \" \")\n        return \"Space\";\n    else if (key.length == 1)\n        return key.toUpperCase();\n    else\n        return key;\n}\n\nexport function keybindToString(keybind: Keybind): string {\n    if (keybind == null || keybind.key == null)\n        return \"\";\n\n    let ret = \"\";\n    if (keybind.ctrl)\n        ret += \"Ctrl + \";\n    if (keybind.alt)\n        ret += \"Alt + \";\n    if (keybind.shift)\n        ret += \"Shift + \";\n\n    return ret += formatKey(keybind.key);\n}","export function isVisible(element: HTMLElement | null, ignoreWidth = false): boolean {\n    if (!element) {\n        return false;\n    }\n\n    // Special case for when a video is first loaded, and the main video element is technically hidden\n    if (element.tagName === \"VIDEO\" \n        && (element.classList.contains(\"html5-main-video\") || element.id === \"player\" || element.id === \"player_html5_api\")\n        && [...document.querySelectorAll(\"video\")].filter((v) => v.duration).length === 1\n        && (element as HTMLVideoElement).duration) {\n        return true;\n    }\n    \n    if (element.offsetHeight === 0 || (element.offsetWidth === 0 && !ignoreWidth)) {\n        return false;\n    }\n\n    const boundingRect = element?.getBoundingClientRect();\n    const elementAtPoint = document.elementFromPoint(boundingRect.left + boundingRect.width / 2,\n        boundingRect.top + boundingRect.height / 2)\n        || document.elementFromPoint(boundingRect.left, boundingRect.top);\n\n    if (!elementAtPoint \n            && element.id === \"movie_player\"\n            && boundingRect.top < 0) {\n        return true;\n    }\n\n    if (elementAtPoint === element \n            || (!!elementAtPoint && element.contains(elementAtPoint))\n            || (!!elementAtPoint && elementAtPoint.contains(element))) {\n        return true;\n    }\n\n    // Hover previews will have their controls appear on top, go back to the nearest player\n    //   to make sure this is the correct element.\n    // If a hover preview is inactive, it will instead have the thumbnail as the top element, which\n    //   is at a different tree to the video player, so it will properly return false for this.\n    // In newer players, it will instead have the \"playing-mode\" class\n    if (element.tagName === \"VIDEO\") {\n        return !!elementAtPoint?.closest(\".html5-video-player\")?.contains(element)\n            || !!element?.closest(\"#inline-preview-player\")?.classList?.contains(\"playing-mode\");\n    }\n\n    return false;\n}\n\nexport function isVisibleOrParent(element: HTMLElement | null, ignoreWidth = false, checkParent = true): boolean {\n    return isVisible(element, ignoreWidth) \n        || (checkParent && !!element && (isVisible(element.parentElement, ignoreWidth) || isVisible(element.parentElement?.parentElement ?? null, ignoreWidth)));\n}\n\nexport function findValidElementFromSelector(selectors: string[], ignoreWidth = false, checkParent = false): HTMLElement | null {\n    return findValidElementFromGenerator(selectors, ignoreWidth, checkParent, (selector) => document.querySelector(selector));\n}\n\nexport function findValidElement(elements: HTMLElement[] | NodeListOf<HTMLElement>, ignoreWidth = false, checkParent = false): HTMLElement | null {\n    return findValidElementFromGenerator(elements, ignoreWidth, checkParent);\n}\n\nfunction findValidElementFromGenerator<T>(objects: T[] | NodeListOf<HTMLElement>, ignoreWidth = false, checkParent = false, generator?: (obj: T) => HTMLElement | null): HTMLElement | null {\n    for (const obj of objects) {\n        const element = generator ? generator(obj as T) : obj as HTMLElement;\n        if (element && isVisibleOrParent(element, ignoreWidth, checkParent)) {\n            return element;\n        }\n    }\n\n    return null;\n}\n\nexport function findPredicatedElement(selectors: string[], predicate: (element: HTMLElement) => boolean): HTMLElement | null {\n    for (const selector of selectors) {\n        const element = document.querySelector(selector) as HTMLElement;\n        if (element && predicate(element)) {\n            return element;\n        }\n    }\n\n    return null;\n}\n\nexport function findNonEmptyElement(selectors: string[]): HTMLElement | null {\n    return findPredicatedElement(selectors, (element) => (element.textContent?.trim() ?? \"\").length > 0);\n}\n\ninterface WaitingElement {\n    selector: string;\n    visibleCheck: boolean;\n    ignoreWidth: boolean;\n    checkParent: boolean;\n    callbacks: Array<(element: Element) => void>;\n    elements?: NodeListOf<HTMLElement>;\n}\n\n/* Used for waitForElement */\nlet creatingWaitingMutationObserver = false;\nlet waitingMutationObserver: MutationObserver | null = null;\nlet waitingElements: WaitingElement[] = [];\n\n/* Uses a mutation observer to wait asynchronously */\nexport async function waitForElement(selector: string, visibleCheck = false, ignoreWidth = false, checkParent = false): Promise<Element> {\n    return await new Promise((resolve) => {\n        const initialElement = getElement(selector, visibleCheck, ignoreWidth, checkParent);\n        if (initialElement) {\n            resolve(initialElement);\n            return;\n        }\n\n        const existingWaitingElement = waitingElements.find((waitingElement) => waitingElement.selector === selector \n            && waitingElement.visibleCheck === visibleCheck);\n\n        if (existingWaitingElement) {\n            existingWaitingElement.callbacks.push(resolve);\n        } else {\n            waitingElements.push({\n                selector,\n                visibleCheck,\n                ignoreWidth,\n                checkParent,\n                callbacks: [resolve]\n            });\n        }\n\n        if (!creatingWaitingMutationObserver) {\n            creatingWaitingMutationObserver = true;\n\n            if (document.body) {\n                setupWaitingMutationListener();\n            } else {\n                window.addEventListener(\"DOMContentLoaded\", () => {\n                    setupWaitingMutationListener();\n                });\n            }\n        }\n    });\n}\n\nfunction setupWaitingMutationListener(): void {\n    if (!waitingMutationObserver) {\n        const checkForObjects = (mutations?: MutationRecord[]) => {\n            const foundSelectors: string[] = [];\n            for (const waitingElement of waitingElements) {\n                const { selector, visibleCheck, ignoreWidth, checkParent, callbacks } = waitingElement;\n\n                let updatePossibleElements = true;\n                if (mutations) {\n                    let found = false;\n                    for (const mutation of mutations) {\n                        if (mutation.type === \"childList\" && mutation.addedNodes.length > 0) {\n                            if (mutation.target instanceof HTMLElement \n                                    && (mutation.target.matches(selector) || mutation.target.querySelector(selector))) {\n                                found = true;\n                                break;\n                            }\n\n                            for (const node of mutation.addedNodes) {\n                                if (node instanceof HTMLElement \n                                        && (node.matches(selector) || node.querySelector(selector))) {\n                                    found = true;\n                                    break;\n                                }\n                            }\n\n                            if (found) {\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!found) {\n                        updatePossibleElements = false;\n                    }\n                }\n\n                const possibleElements: NodeListOf<HTMLElement> | undefined =\n                    updatePossibleElements ? document.querySelectorAll(selector) : waitingElement.elements;\n                if (possibleElements && possibleElements.length > 0) {\n                    waitingElement.elements = possibleElements;\n\n                    const element = visibleCheck ? findValidElement(possibleElements, ignoreWidth, checkParent) : possibleElements[0] as HTMLElement;\n                    if (element) {\n                        if (chrome.runtime?.id) {\n                            for (const callback of callbacks) {\n                                callback(element);\n                            }\n                        }\n\n                        foundSelectors.push(selector);\n                    }\n                }\n            }\n\n            waitingElements = waitingElements.filter((element) => !foundSelectors.includes(element.selector));\n            \n            if (waitingElements.length === 0) {\n                waitingMutationObserver?.disconnect();\n                waitingMutationObserver = null;\n                creatingWaitingMutationObserver = false;\n            }\n        };\n\n        // Do an initial check over all objects\n        checkForObjects();\n\n        if (waitingElements.length > 0) {\n            waitingMutationObserver = new MutationObserver(checkForObjects);\n\n            waitingMutationObserver.observe(document.documentElement, {\n                childList: true,\n                subtree: true\n            });\n        }\n    }\n}\n\nexport function getElement(selector: string, visibleCheck: boolean, ignoreWidth = false, checkParent = false) {\n    return visibleCheck ? findValidElement(document.querySelectorAll(selector), ignoreWidth, checkParent) : document.querySelector(selector) as HTMLElement;\n}","export function getFormattedTimeToSeconds(formatted: string): number | null {\n    const fragments = /^(?:(?:(\\d+):)?(\\d+):)?(\\d*(?:[.,]\\d+)?)$/.exec(formatted);\n\n    if (fragments === null) {\n        return null;\n    }\n\n    const hours = fragments[1] ? parseInt(fragments[1]) : 0;\n    const minutes = fragments[2] ? parseInt(fragments[2] || '0') : 0;\n    const seconds = fragments[3] ? parseFloat(fragments[3].replace(',', '.')) : 0;\n\n    return hours * 3600 + minutes * 60 + seconds;\n}\n\nexport function getFormattedTime(seconds: number, precise?: boolean): string | null {\n    seconds = Math.max(seconds, 0);\n    \n    const hours = Math.floor(seconds / 60 / 60);\n    const minutes = Math.floor(seconds / 60) % 60;\n    let minutesDisplay = String(minutes);\n    let secondsNum = seconds % 60;\n    if (!precise) {\n        secondsNum = Math.floor(secondsNum);\n    }\n\n    let secondsDisplay = String(precise ? secondsNum.toFixed(3) : secondsNum);\n    \n    if (secondsNum < 10) {\n        //add a zero\n        secondsDisplay = \"0\" + secondsDisplay;\n    }\n    if (hours && minutes < 10) {\n        //add a zero\n        minutesDisplay = \"0\" + minutesDisplay;\n    }\n    if (isNaN(hours) || isNaN(minutes)) {\n        return null;\n    }\n\n    const formatted = (hours ? hours + \":\" : \"\") + minutesDisplay + \":\" + secondsDisplay;\n\n    return formatted;\n}\n\n/**\n * Gets the error message in a nice string\n *\n * The result should be a single line string, suitable for small display spaces.\n * \n * @param {int} statusCode \n * @returns {string} errorMessage\n */\nexport function getShortErrorMessage(statusCode: number, responseText: string): string {\n    // timeout\n    if (statusCode === 0) {\n        return chrome.i18n.getMessage(\"0\");\n    }\n    // prep the strings\n    const errorMessage = (\n        (responseText\n            && !(responseText.includes(`cf-wrapper`) || responseText.includes(\"<!DOCTYPE html>\"))\n            && responseText.length < 64 // this value is very much arbitrary\n        )\n            ? ` ${responseText}`\n            : \"\"\n    );\n    // use the 502 string for 503s\n    let introString = chrome.i18n.getMessage(`${statusCode === 503 ? 502 : statusCode}`);\n    if (introString === \"\") {\n        introString = chrome.i18n.getMessage(\"connectionError\");\n    }\n    const errorCodeString = chrome.i18n.getMessage(\"errorCode\").replace(\"{code}\", `${statusCode}${errorMessage}`);\n    return `${introString} ${errorCodeString}`;\n}\n\n/**\n * Checks if the body is worth displaying to the user/logs\n *\n * @param body the body\n * @returns true if the body should be considered \"garbage\", false if it's potentially valuable\n */\nexport function isBodyGarbage(body: string): boolean {\n    return body.startsWith(\"<!DOCTYPE html>\") || body.startsWith(\"<html>\") || body.includes(`cf-wrapper`);\n}\n\n/**\n * Gets the error message in a nice string\n * \n * The result will be a longer, multiline string, suitable for long-lived error notices or alerts.\n *\n * @param {int} statusCode \n * @returns {string} errorMessage\n */\nexport function getLongErrorMessage(statusCode: number, responseText: string): string {\n    // timeout\n    if (statusCode === 0) {\n        return chrome.i18n.getMessage(\"0\");\n    }\n    // prep the strings\n    const postFix = (responseText && !isBodyGarbage(responseText)) ? \"\\n\\n\" + responseText : \"\";\n    // use the 502 string for 503s\n    let introString = chrome.i18n.getMessage(`${statusCode === 503 ? 502 : statusCode}`);\n    if (introString === \"\") {\n        introString = chrome.i18n.getMessage(\"connectionError\");\n    }\n    const errorCodeString = chrome.i18n.getMessage(\"errorCode\").replace(\"{code}\", `${statusCode}`);\n    const reminder = (statusCode === 502 || statusCode === 503) ? `\\n\\n${chrome.i18n.getMessage(\"statusReminder\")}` : \"\";\n    return `${introString} ${errorCodeString}${postFix}${reminder}`;\n}\n\n/**\n * Formats the JS error message in a nice string\n * \n * @param error The error to format\n * @returns {string} The nice string\n */\nexport function formatJSErrorMessage(error: string | Error): string {\n    const introString =  chrome.i18n.getMessage(\"connectionError\");\n    return `${introString} ${error}`\n}\n","export type HashedValue = string & { __hashBrand: unknown };\n\nexport async function getHash<T extends string>(value: T, times = 5000): Promise<T & HashedValue> {\n    if (times <= 0) return \"\" as T & HashedValue;\n\n    if (!(\"subtle\" in crypto)) {\n        // Run in background script instead\n        return new Promise((resolve, reject) => chrome.runtime.sendMessage({\n            message: \"getHash\",\n            value,\n            times\n        }, (response) => {\n            if (response.error) {\n                reject(response.error);\n            } else {\n                resolve(response);\n            }\n        }));\n    }\n\n    let hashHex: string = value;\n    for (let i = 0; i < times; i++) {\n        const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(hashHex).buffer);\n\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n    }\n\n    return hashHex as T & HashedValue;\n}","/** Function that can be used to wait for a condition before returning. */\nexport async function waitFor<T>(condition: () => T, timeout = 5000, check = 100, predicate?: (obj: T) => boolean): Promise<T> {\n    return await new Promise((resolve, reject) => {\n        let interval: NodeJS.Timeout | null = null;\n\n        const intervalCheck = () => {\n            const result = condition();\n            if (predicate ? predicate(result) : result) {\n                resolve(result);\n                if (interval) clearInterval(interval);\n            }\n        };\n\n        if (timeout) {\n            setTimeout(() => {\n                clearInterval(interval!);\n                reject(`TIMEOUT waiting for ${condition?.toString()}: ${Error().stack}`);\n            }, timeout);\n\n            interval = setInterval(intervalCheck, check);\n        }\n        \n        // Run the check once first, this speeds it up a lot\n        intervalCheck();\n    });\n}\n\nexport function objectToURI<T>(url: string, data: T, includeQuestionMark: boolean): string {\n    let counter = 0;\n    for (const key in data) {\n        const seperator = (url.includes(\"?\") || counter > 0) ? \"&\" : (includeQuestionMark ? \"?\" : \"\");\n        const value = (typeof(data[key]) === \"string\") ? data[key] as unknown as string : JSON.stringify(data[key]);\n        url += seperator + encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n\n        counter++;\n    }\n\n    return url;\n}\n\nexport class PromiseTimeoutError<T> extends Error {\n    promise?: Promise<T>;\n\n    constructor(promise?: Promise<T>) {\n        super(\"Promise timed out\");\n\n        this.promise = promise;\n    }\n}\n\nexport function timeoutPomise<T>(timeout?: number): Promise<T> {\n    return new Promise((resolve, reject) => {\n        if (timeout) {\n            setTimeout(() => {\n                reject(new PromiseTimeoutError());\n            }, timeout);\n        }\n    });\n}\n\n/**\n* web-extensions\n*/\nconst onFirefoxOrSafari = typeof(chrome) !== \"undefined\" && !!chrome.runtime.getManifest().browser_specific_settings;\nconst onFirefox = typeof(chrome) !== \"undefined\" && !!chrome.runtime.getManifest().browser_specific_settings?.gecko;\nexport function isFirefox(): boolean {\n    return onFirefox;\n}\nexport function isFirefoxOrSafari(): boolean {\n    return onFirefoxOrSafari;\n}\n\nlet cachedUserAgent: string;\nexport function extensionUserAgent(): string {\n    cachedUserAgent ??= `${chrome.runtime.id}/v${chrome.runtime.getManifest().version}`;\n    return cachedUserAgent;\n}\n","export function generateUserID(length = 36): string {\n    const charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    const cryptoFuncs = typeof window === \"undefined\" ? crypto : window.crypto;\n    if (cryptoFuncs && cryptoFuncs.getRandomValues) {\n            const values = new Uint32Array(length);\n            cryptoFuncs.getRandomValues(values);\n            for (let i = 0; i < length; i++) {\n                    result += charset[values[i] % charset.length];\n            }\n            return result;\n    } else {\n            for (let i = 0; i < length; i++) {\n                result += charset[Math.floor(Math.random() * charset.length)];\n            }\n            return result;\n    }\n}\n\nexport function localizeHtmlPage(): void {\n    // Localize by replacing __MSG_***__ meta tags\n    const localizedTitle = getLocalizedMessage(document.title);\n    if (localizedTitle) document.title = localizedTitle;\n\n    const body = document.querySelector(\".sponsorBlockPageBody\");\n    const localizedMessage = getLocalizedMessage(body!.innerHTML.toString());\n    if (localizedMessage) body!.innerHTML = localizedMessage;\n}\n\nexport function getLocalizedMessage(text: string): string | false {\n    const valNewH = text.replace(/__MSG_(\\w+)__/g, function(match, v1) {\n        return v1 ? chrome.i18n.getMessage(v1).replace(/</g, \"&#60;\")\n            .replace(/\"/g, \"&quot;\").replace(/\\n/g, \"<br/>\") : \"\";\n    });\n\n    if (valNewH != text) {\n        return valNewH;\n    } else {\n        return false;\n    }\n}","import { waitFor } from \".\";\nimport { LocalStorage, ProtoConfig, SyncStorage } from \"./config\";\n\nfunction onTabUpdatedListener(tabId: number) {\n    chrome.tabs.sendMessage(tabId, {\n        message: 'update',\n    }, () => void chrome.runtime.lastError ); // Suppress error on Firefox\n}\n\nfunction onNavigationApiAvailableChange(changes: {[key: string]: chrome.storage.StorageChange}) {\n    if (changes.navigationApiAvailable) {\n        if (changes.navigationApiAvailable.newValue) {\n            chrome.tabs.onUpdated.removeListener(onTabUpdatedListener);\n        } else {\n            chrome.tabs.onUpdated.addListener(onTabUpdatedListener);\n        }\n    }\n}\n\nexport function setupTabUpdates<T extends SyncStorage, U extends LocalStorage>(config: ProtoConfig<T, U>) {\n    // If Navigation API is not supported, then background has to inform content script about video change.\n    // This happens on Safari, Firefox, and Chromium 101 (inclusive) and below.\n    chrome.tabs.onUpdated.addListener(onTabUpdatedListener);\n    void waitFor(() => config.local !== null).then(() => {\n        if (config.local!.navigationApiAvailable) {\n            chrome.tabs.onUpdated.removeListener(onTabUpdatedListener);\n        }\n    });\n\n    if (!config.configSyncListeners.includes(onNavigationApiAvailableChange)) {\n        config.configSyncListeners.push(onNavigationApiAvailableChange);\n    }\n}","import * as CompileConfig from \"../config.json\";\n\nimport Config from \"./config\";\nimport { Registration } from \"./types\";\nimport \"content-scripts-register-polyfill\";\nimport { sendRealRequestToCustomServer, serializeOrStringify, setupBackgroundRequestProxy } from \"../maze-utils/src/background-request-proxy\";\nimport { setupTabUpdates } from \"../maze-utils/src/tab-updates\";\nimport { generateUserID } from \"../maze-utils/src/setup\";\n\nimport Utils from \"./utils\";\nimport { getExtensionIdsToImportFrom } from \"./utils/crossExtension\";\nimport { isFirefoxOrSafari, waitFor } from \"../maze-utils/src\";\nimport { injectUpdatedScripts } from \"../maze-utils/src/cleanup\";\nimport { logWarn } from \"./utils/logger\";\nimport { chromeP } from \"../maze-utils/src/browserApi\";\nimport { getHash } from \"../maze-utils/src/hash\";\nconst utils = new Utils({\n    registerFirefoxContentScript,\n    unregisterFirefoxContentScript\n});\n\nconst popupPort: Record<string, chrome.runtime.Port> = {};\n\n// Used only on Firefox, which does not support non persistent background pages.\nconst contentScriptRegistrations = {};\n\n// Register content script if needed\nutils.wait(() => Config.isReady()).then(function() {\n    if (Config.config.supportInvidious) utils.setupExtraSiteContentScripts();\n});\n\nsetupBackgroundRequestProxy();\nsetupTabUpdates(Config);\n\nchrome.runtime.onMessage.addListener(function (request, sender, callback) {\n    switch(request.message) {\n        case \"openConfig\":\n            chrome.tabs.create({url: chrome.runtime.getURL('options/options.html' + (request.hash ? '#' + request.hash : ''))});\n            return false;\n        case \"openHelp\":\n            chrome.tabs.create({url: chrome.runtime.getURL('help/index.html')});\n            return false;\n        case \"openPage\":\n            chrome.tabs.create({url: chrome.runtime.getURL(request.url)});\n            return false;\n        case \"submitVote\":\n            submitVote(request.type, request.UUID, request.category, request.videoID).then(callback);\n\n            //this allows the callback to be called later\n            return true;\n        case \"registerContentScript\":\n            registerFirefoxContentScript(request);\n            return false;\n        case \"unregisterContentScript\":\n            unregisterFirefoxContentScript(request.id)\n            return false;\n        case \"tabs\": {\n            chrome.tabs.query({\n                active: true,\n                currentWindow: true\n            }, tabs => {\n                chrome.tabs.sendMessage(\n                    tabs[0].id,\n                    request.data,\n                    (response) => {\n                        callback(response);\n                    }\n                );\n            });\n            return true;\n        }\n        case \"time\":\n        case \"infoUpdated\":\n        case \"videoChanged\":\n            if (sender.tab) {\n                try {\n                    popupPort[sender.tab.id]?.postMessage(request);\n                } catch (e) {\n                    // This can happen if the popup is closed\n                }\n            }\n            return false;\n        default:\n            return false;\n\t}\n});\n\nchrome.runtime.onMessageExternal.addListener((request, sender, callback) => {\n    if (getExtensionIdsToImportFrom().includes(sender.id)) {\n        if (request.message === \"requestConfig\") {\n            callback({\n                userID: Config.config.userID,\n                allowExpirements: Config.config.allowExpirements,\n                showDonationLink: Config.config.showDonationLink,\n                showUpsells: Config.config.showUpsells,\n                darkMode: Config.config.darkMode,\n            })\n        }\n    }\n});\n\nchrome.runtime.onConnect.addListener((port) => {\n    if (port.name === \"popup\") {\n        chrome.tabs.query({\n            active: true,\n            currentWindow: true\n        }, tabs => {\n            popupPort[tabs[0].id] = port;\n        });\n    }\n});\n\n//add help page on install\nchrome.runtime.onInstalled.addListener(function () {\n    // This let's the config sync to run fully before checking.\n    // This is required on Firefox\n    setTimeout(async () => {\n        const userID = Config.config.userID;\n\n        // If there is no userID, then it is the first install.\n        if (!userID && !Config.local.alreadyInstalled){\n            //open up the install page\n            chrome.tabs.create({url: chrome.runtime.getURL(\"/help/index.html\")});\n\n            //generate a userID\n            const newUserID = generateUserID();\n            //save this UUID\n            Config.config.userID = newUserID;\n            Config.local.alreadyInstalled = true;\n\n            // Don't show update notification\n            Config.config.categoryPillUpdate = true;\n        }\n\n        if (Config.config.supportInvidious) {\n            if (!(await utils.containsInvidiousPermission())) {\n                chrome.tabs.create({url: chrome.runtime.getURL(\"/permissions/index.html\")});\n            }\n        }\n\n        getHash(Config.config!.userID!).then((userID) => {\n            if (userID == \"60eed03c8644b7efa32df06977b3a4c11b62f63518e74a0e29baa1fd449cb54f\") {\n                Config.config.prideTheme = true;\n            }\n        });\n    }, 1500);\n\n    if (!isFirefoxOrSafari()) {\n        injectUpdatedScripts().catch(logWarn);\n\n        waitFor(() => Config.isReady()).then(() => {\n            if (Config.config.supportInvidious) {\n                injectUpdatedScripts([\n                    utils.getExtraSiteRegistration()\n                ])\n            }\n        }).catch(logWarn);\n    }\n});\n\n/**\n * Only works on Firefox.\n * Firefox requires that it be applied after every extension restart.\n *\n * @param {JSON} options\n */\nasync function registerFirefoxContentScript(options: Registration) {\n    if (\"scripting\" in chrome && \"getRegisteredContentScripts\" in chrome.scripting) {\n        const existingRegistrations = await chromeP.scripting.getRegisteredContentScripts({\n            ids: [options.id]\n        }).catch(() => []);\n\n        if (existingRegistrations && existingRegistrations.length > 0 \n            && options.matches.every((match) => existingRegistrations[0].matches.includes(match))) {\n            // No need to register another script, already registered\n            return;\n        }\n    }\n\n    await unregisterFirefoxContentScript(options.id);\n\n    if (\"scripting\" in chrome && \"getRegisteredContentScripts\" in chrome.scripting) {\n        await chromeP.scripting.registerContentScripts([{\n            id: options.id,\n            runAt: \"document_start\",\n            matches: options.matches,\n            allFrames: options.allFrames,\n            js: options.js,\n            css: options.css,\n            persistAcrossSessions: true,\n        }]);\n    } else {\n        chrome.contentScripts.register({\n            allFrames: options.allFrames,\n            js: options.js?.map?.(file => ({file})),\n            css: options.css?.map?.(file => ({file})),\n            matches: options.matches\n        }).then((registration) => void (contentScriptRegistrations[options.id] = registration));\n    }\n\n}\n\n/**\n * Only works on Firefox.\n * Firefox requires that this is handled by the background script\n */\nasync function  unregisterFirefoxContentScript(id: string) {\n    if (\"scripting\" in chrome && \"getRegisteredContentScripts\" in chrome.scripting) {\n        try {\n            await chromeP.scripting.unregisterContentScripts({\n                ids: [id]\n            });\n        } catch (e) {\n            // Not registered yet\n        }\n    } else {\n        if (contentScriptRegistrations[id]) {\n            contentScriptRegistrations[id].unregister();\n            delete contentScriptRegistrations[id];\n        }\n    }\n}\n\nasync function submitVote(type: number, UUID: string, category: string, videoID: string) {\n    let userID = Config.config.userID;\n\n    if (userID == undefined || userID === \"undefined\") {\n        //generate one\n        userID = generateUserID();\n        Config.config.userID = userID;\n    }\n\n    const typeSection = (type !== undefined) ? \"&type=\" + type : \"&category=\" + category;\n\n    try {\n        const response = await asyncRequestToServer(\"POST\", \"/api/voteOnSponsorTime?UUID=\" + UUID + \"&videoID=\" + videoID + \"&userID=\" + userID + typeSection);\n\n        return {\n            status: response.status,\n            ok: response.ok,\n            responseText: await response.text(),\n        };\n    } catch (e) {\n        console.error(\"Error while voting:\", e);\n        return {\n            error: serializeOrStringify(e),\n        };\n    }\n}\n\n\nasync function asyncRequestToServer(type: string, address: string, data = {}) {\n    const serverAddress = Config.config.testingServer ? CompileConfig.testingServerAddress : Config.config.serverAddress;\n\n    return await (sendRealRequestToCustomServer(type, serverAddress + address, data));\n}\n","import * as CompileConfig from \"../config.json\";\nimport * as invidiousList from \"../ci/invidiouslist.json\";\nimport { Category, CategorySelection, CategorySkipOption, NoticeVisibilityMode, PreviewBarOption, SponsorHideType, SponsorTime, VideoID, SegmentListDefaultTab } from \"./types\";\nimport { Keybind, keybindEquals, ProtoConfig } from \"../maze-utils/src/config\";\nimport type { HashedValue } from \"../maze-utils/src/hash\";\nimport { AdvancedSkipCheck, AdvancedSkipPredicate, AdvancedSkipRule, Permission, PredicateOperator } from \"./utils/skipRule.type\";\n\ninterface SBConfig {\n    userID: string;\n    isVip: boolean;\n    permissions: Record<Category, Permission>;\n    defaultCategory: Category;\n    segmentListDefaultTab: SegmentListDefaultTab;\n    renderSegmentsAsChapters: boolean;\n    forceChannelCheck: boolean;\n    minutesSaved: number;\n    skipCount: number;\n    sponsorTimesContributed: number;\n    submissionCountSinceCategories: number; // New count used to show the \"Read The Guidelines!!\" message\n    showTimeWithSkips: boolean;\n    disableSkipping: boolean;\n    muteSegments: boolean;\n    fullVideoSegments: boolean;\n    fullVideoLabelsOnThumbnails: boolean;\n    manualSkipOnFullVideo: boolean;\n    trackViewCount: boolean;\n    trackViewCountInPrivate: boolean;\n    trackDownvotes: boolean;\n    trackDownvotesInPrivate: boolean;\n    dontShowNotice: boolean;\n    showUpcomingNotice: boolean;\n    noticeVisibilityMode: NoticeVisibilityMode;\n    hideVideoPlayerControls: boolean;\n    hideInfoButtonPlayerControls: boolean;\n    hideDeleteButtonPlayerControls: boolean;\n    hideUploadButtonPlayerControls: boolean;\n    hideSkipButtonPlayerControls: boolean;\n    hideDiscordLaunches: number;\n    hideDiscordLink: boolean;\n    invidiousInstances: string[];\n    supportInvidious: boolean;\n    serverAddress: string;\n    minDuration: number;\n    skipNoticeDuration: number;\n    audioNotificationOnSkip: boolean;\n    checkForUnlistedVideos: boolean;\n    testingServer: boolean;\n    ytInfoPermissionGranted: boolean;\n    allowExpirements: boolean;\n    showDonationLink: boolean;\n    showPopupDonationCount: number;\n    showUpsells: boolean;\n    showNewFeaturePopups: boolean;\n    donateClicked: number;\n    autoHideInfoButton: boolean;\n    autoSkipOnMusicVideos: boolean;\n    skipNonMusicOnlyOnYoutubeMusic: boolean;\n    colorPalette: {\n        red: string;\n        white: string;\n        locked: string;\n    };\n    scrollToEditTimeUpdate: boolean;\n    categoryPillUpdate: boolean;\n    hookUpdate: boolean;\n    showChapterInfoMessage: boolean;\n    darkMode: boolean;\n    showCategoryGuidelines: boolean;\n    showCategoryWithoutPermission: boolean;\n    showSegmentNameInChapterBar: boolean;\n    showAutogeneratedChapters: boolean;\n    useVirtualTime: boolean;\n    showSegmentFailedToFetchWarning: boolean;\n    allowScrollingToEdit: boolean;\n    deArrowInstalled: boolean;\n    showDeArrowPromotion: boolean;\n    showDeArrowInSettings: boolean;\n    shownDeArrowPromotion: boolean;\n    showZoomToFillError2: boolean;\n    cleanPopup: boolean;\n    hideSegmentCreationInPopup: boolean;\n    prideTheme: boolean;\n\n    // Used to cache calculated text color info\n    categoryPillColors: {\n        [key in Category]: {\n            lastColor: string;\n            textColor: string;\n        }\n    };\n\n    skipKeybind: Keybind;\n    skipToHighlightKeybind: Keybind;\n    startSponsorKeybind: Keybind;\n    submitKeybind: Keybind;\n    actuallySubmitKeybind: Keybind;\n    previewKeybind: Keybind;\n    nextChapterKeybind: Keybind;\n    previousChapterKeybind: Keybind;\n    closeSkipNoticeKeybind: Keybind;\n    upvoteKeybind: Keybind;\n    downvoteKeybind: Keybind;\n\n    // What categories should be skipped\n    categorySelections: CategorySelection[];\n\n    payments: {\n        licenseKey: string;\n        lastCheck: number;\n        lastFreeCheck: number;\n        freeAccess: boolean;\n        chaptersAllowed: boolean;\n    };\n\n    // Preview bar\n    barTypes: {\n        \"preview-chooseACategory\": PreviewBarOption;\n        \"sponsor\": PreviewBarOption;\n        \"preview-sponsor\": PreviewBarOption;\n        \"selfpromo\": PreviewBarOption;\n        \"preview-selfpromo\": PreviewBarOption;\n        \"exclusive_access\": PreviewBarOption;\n        \"interaction\": PreviewBarOption;\n        \"preview-interaction\": PreviewBarOption;\n        \"intro\": PreviewBarOption;\n        \"preview-intro\": PreviewBarOption;\n        \"outro\": PreviewBarOption;\n        \"preview-outro\": PreviewBarOption;\n        \"preview\": PreviewBarOption;\n        \"preview-preview\": PreviewBarOption;\n        \"music_offtopic\": PreviewBarOption;\n        \"preview-music_offtopic\": PreviewBarOption;\n        \"poi_highlight\": PreviewBarOption;\n        \"preview-poi_highlight\": PreviewBarOption;\n        \"filler\": PreviewBarOption;\n        \"preview-filler\": PreviewBarOption;\n    };\n}\n\nexport type VideoDownvotes = { segments: { uuid: HashedValue; hidden: SponsorHideType }[]; lastAccess: number };\n\nexport type ConfigurationID = string & { __configurationID: never };\n\nexport interface CustomConfiguration {\n    name: string;\n    categorySelections: CategorySelection[];\n    showAutogeneratedChapters: boolean | null;\n    autoSkipOnMusicVideos: boolean | null;\n    skipNonMusicOnlyOnYoutubeMusic: boolean | null;\n    muteSegments: boolean | null;\n    fullVideoSegments: boolean | null;\n    manualSkipOnFullVideo: boolean | null;\n    minDuration: number | null;\n}\n\ninterface SBStorage {\n    /* VideoID prefixes to UUID prefixes */\n    downvotedSegments: Record<VideoID & HashedValue, VideoDownvotes>;\n    navigationApiAvailable: boolean;\n\n    // Used when sync storage disabled\n    alreadyInstalled: boolean;\n\n    /* Contains unsubmitted segments that the user has created. */\n    unsubmittedSegments: Record<string, SponsorTime[]>;\n\n    channelSkipProfileIDs: Record<string, ConfigurationID>;\n    skipProfileTemp: { time: number; configID: ConfigurationID } | null;\n    skipProfiles: Record<ConfigurationID, CustomConfiguration>;\n\n    skipRules: AdvancedSkipRule[];\n}\n\nclass ConfigClass extends ProtoConfig<SBConfig, SBStorage> {\n    resetToDefault() {\n        chrome.storage.sync.set({\n            ...this.syncDefaults,\n            userID: this.config.userID,\n            minutesSaved: this.config.minutesSaved,\n            skipCount: this.config.skipCount,\n            sponsorTimesContributed: this.config.sponsorTimesContributed\n        });\n\n        chrome.storage.local.set({\n            ...this.localDefaults,\n        });\n    }\n}\n\nfunction migrateOldSyncFormats(config: SBConfig, local: SBStorage) {\n    if (local[\"skipRules\"] && local[\"skipRules\"].length !== 0 && local[\"skipRules\"][0][\"rules\"]) {\n        const output: AdvancedSkipRule[] = [];\n\n        for (const rule of local[\"skipRules\"]) {\n            const rules: object[] = rule[\"rules\"];\n\n            if (rules.length !== 0) {\n                let predicate: AdvancedSkipPredicate = {\n                    kind: \"check\",\n                    ...rules[0] as AdvancedSkipCheck,\n                };\n\n                for (let i = 1; i < rules.length; i++) {\n                    predicate = {\n                        kind: \"operator\",\n                        operator: PredicateOperator.And,\n                        left: predicate,\n                        right: {\n                            kind: \"check\",\n                            ...rules[i] as AdvancedSkipCheck,\n                        },\n                    };\n                }\n\n                const comment = rule[\"comment\"] as string;\n\n                output.push({\n                    predicate,\n                    skipOption: rule.skipOption,\n                    comments: comment.length === 0 ? [] : comment.split(/;\\s*/),\n                });\n            }\n        }\n\n        local[\"skipRules\"] = output;\n    }\n\n    if (config[\"whitelistedChannels\"]) {\n        // convert to skipProfiles\n        const whitelistedChannels = config[\"whitelistedChannels\"] as string[];\n        const skipProfileID: ConfigurationID = \"default-whitelist\" as ConfigurationID;\n\n        local.skipProfiles[skipProfileID] = {\n            name: chrome.i18n.getMessage(\"WhitelistedChannels\"),\n            categorySelections: config.categorySelections\n                .filter((s) => ![\"exclusive_access\", \"chapter\"].includes(s.name))\n                .map(s => ({\n                    name: s.name,\n                    option: CategorySkipOption.ShowOverlay\n            })),\n            showAutogeneratedChapters: null,\n            autoSkipOnMusicVideos: null,\n            skipNonMusicOnlyOnYoutubeMusic: null,\n            muteSegments: null,\n            fullVideoSegments: null,\n            manualSkipOnFullVideo: null,\n            minDuration: null\n        };\n        local.skipProfiles = local.skipProfiles;\n\n        for (const channelID of whitelistedChannels) {\n            local.channelSkipProfileIDs[channelID] = skipProfileID;\n        }\n        local.channelSkipProfileIDs = local.channelSkipProfileIDs;\n\n        chrome.storage.sync.remove(\"whitelistedChannels\");\n    }\n\n    if (!config[\"changeChapterColor\"]) {\n        config.barTypes[\"chapter\"].color = \"#ffd983\";\n        config[\"changeChapterColor\"] = true;\n        chrome.storage.sync.set({\n            \"changeChapterColor\": true,\n            \"barTypes\": config.barTypes\n        });\n    }\n\n    if (config[\"showZoomToFillError\"]) {\n        chrome.storage.sync.remove(\"showZoomToFillError\");\n    }\n\n    if (config[\"unsubmittedSegments\"] && Object.keys(config[\"unsubmittedSegments\"]).length > 0) {\n        chrome.storage.local.set({\n            unsubmittedSegments: config[\"unsubmittedSegments\"]\n        }, () => {\n            chrome.storage.sync.remove(\"unsubmittedSegments\");\n        });\n    }\n\n    if (!config[\"chapterCategoryAdded\"]) {\n        config[\"chapterCategoryAdded\"] = true;\n\n        if (!config.categorySelections.some((s) => s.name === \"chapter\")) {\n            config.categorySelections.push({\n                name: \"chapter\" as Category,\n                option: CategorySkipOption.ShowOverlay\n            });\n\n            config.categorySelections = config.categorySelections;\n        }\n    }\n\n    if (config[\"exclusive_accessCategoryAdded\"] !== undefined) {\n        chrome.storage.sync.remove(\"exclusive_accessCategoryAdded\");\n    }\n\n    if (config[\"fillerUpdate\"] !== undefined) {\n        chrome.storage.sync.remove(\"fillerUpdate\");\n    }\n    if (config[\"highlightCategoryAdded\"] !== undefined) {\n        chrome.storage.sync.remove(\"highlightCategoryAdded\");\n    }\n    if (config[\"highlightCategoryUpdate\"] !== undefined) {\n        chrome.storage.sync.remove(\"highlightCategoryUpdate\");\n    }\n\n    if (config[\"askAboutUnlistedVideos\"]) {\n        chrome.storage.sync.remove(\"askAboutUnlistedVideos\");\n    }\n\n    if (!config[\"autoSkipOnMusicVideosUpdate\"]) {\n        config[\"autoSkipOnMusicVideosUpdate\"] = true;\n        for (const selection of config.categorySelections) {\n            if (selection.name === \"music_offtopic\"\n                && selection.option === CategorySkipOption.AutoSkip) {\n\n                config.autoSkipOnMusicVideos = true;\n                break;\n            }\n        }\n    }\n\n    if (config[\"disableAutoSkip\"]) {\n        for (const selection of config.categorySelections) {\n            if (selection.name === \"sponsor\") {\n                selection.option = CategorySkipOption.ManualSkip;\n\n                chrome.storage.sync.remove(\"disableAutoSkip\");\n            }\n        }\n    }\n\n    if (typeof config[\"skipKeybind\"] == \"string\") {\n        config[\"skipKeybind\"] = { key: config[\"skipKeybind\"] };\n    }\n\n    if (typeof config[\"startSponsorKeybind\"] == \"string\") {\n        config[\"startSponsorKeybind\"] = { key: config[\"startSponsorKeybind\"] };\n    }\n\n    if (typeof config[\"submitKeybind\"] == \"string\") {\n        config[\"submitKeybind\"] = { key: config[\"submitKeybind\"] };\n    }\n\n    // Unbind key if it matches a previous one set by the user (should be ordered oldest to newest)\n    const keybinds = [\"skipKeybind\", \"startSponsorKeybind\", \"submitKeybind\"];\n    for (let i = keybinds.length - 1; i >= 0; i--) {\n        for (let j = 0; j < keybinds.length; j++) {\n            if (i == j)\n                continue;\n            if (keybindEquals(config[keybinds[i]], config[keybinds[j]]))\n                config[keybinds[i]] = null;\n        }\n    }\n\n    // Remove some old unused options\n    if (config[\"sponsorVideoID\"] !== undefined) {\n        chrome.storage.sync.remove(\"sponsorVideoID\");\n    }\n    if (config[\"previousVideoID\"] !== undefined) {\n        chrome.storage.sync.remove(\"previousVideoID\");\n    }\n\n    // populate invidiousInstances with new instances if 3p support is **DISABLED**\n    if (!config[\"supportInvidious\"] && config[\"invidiousInstances\"].length < invidiousList.length) {\n        config[\"invidiousInstances\"] = [...new Set([...invidiousList, ...config[\"invidiousInstances\"]])];\n    }\n\n    if (config[\"lastIsVipUpdate\"]) {\n        chrome.storage.sync.remove(\"lastIsVipUpdate\");\n    }\n}\n\nconst syncDefaults = {\n    userID: null,\n    isVip: false,\n    permissions: {},\n    defaultCategory: \"chooseACategory\" as Category,\n    segmentListDefaultTab: SegmentListDefaultTab.Segments,\n    renderSegmentsAsChapters: false,\n    forceChannelCheck: false,\n    minutesSaved: 0,\n    skipCount: 0,\n    sponsorTimesContributed: 0,\n    submissionCountSinceCategories: 0,\n    showTimeWithSkips: true,\n    disableSkipping: false,\n    muteSegments: true,\n    fullVideoSegments: true,\n    fullVideoLabelsOnThumbnails: true,\n    manualSkipOnFullVideo: false,\n    trackViewCount: true,\n    trackViewCountInPrivate: true,\n    trackDownvotes: true,\n    trackDownvotesInPrivate: false,\n    dontShowNotice: false,\n    showUpcomingNotice: false,\n    noticeVisibilityMode: NoticeVisibilityMode.FadedForAutoSkip,\n    hideVideoPlayerControls: false,\n    hideInfoButtonPlayerControls: false,\n    hideDeleteButtonPlayerControls: false,\n    hideUploadButtonPlayerControls: false,\n    hideSkipButtonPlayerControls: false,\n    hideDiscordLaunches: 0,\n    hideDiscordLink: false,\n    invidiousInstances: [],\n    supportInvidious: false,\n    serverAddress: CompileConfig.serverAddress,\n    minDuration: 0,\n    skipNoticeDuration: 4,\n    audioNotificationOnSkip: false,\n    checkForUnlistedVideos: false,\n    testingServer: false,\n    ytInfoPermissionGranted: false,\n    allowExpirements: true,\n    showDonationLink: true,\n    showPopupDonationCount: 0,\n    showUpsells: true,\n    showNewFeaturePopups: true,\n    donateClicked: 0,\n    autoHideInfoButton: true,\n    autoSkipOnMusicVideos: false,\n    skipNonMusicOnlyOnYoutubeMusic: false,\n    scrollToEditTimeUpdate: false, // false means the tooltip will be shown\n    categoryPillUpdate: false,\n    hookUpdate: false,\n    showChapterInfoMessage: true,\n    darkMode: true,\n    showCategoryGuidelines: true,\n    showCategoryWithoutPermission: false,\n    showSegmentNameInChapterBar: true,\n    showAutogeneratedChapters: true,\n    useVirtualTime: true,\n    showSegmentFailedToFetchWarning: true,\n    allowScrollingToEdit: true,\n    deArrowInstalled: false,\n    showDeArrowPromotion: true,\n    showDeArrowInSettings: true,\n    shownDeArrowPromotion: false,\n    showZoomToFillError2: true,\n    cleanPopup: false,\n    hideSegmentCreationInPopup: false,\n    prideTheme: false,\n\n    categoryPillColors: {},\n\n    /**\n     * Default keybinds should not set \"code\" as that's gonna be different based on the user's locale. They should also only use EITHER ctrl OR alt modifiers (or none).\n     * Using ctrl+alt, or shift may produce a different character that we will not be able to recognize in different locales.\n     * The exception for shift is letters, where it only capitalizes. So shift+A is fine, but shift+1 isn't.\n     * Don't forget to add the new keybind to the checks in \"KeybindDialogComponent.isKeybindAvailable()\" and in \"migrateOldFormats()\"!\n     *      TODO: Find a way to skip having to update these checks. Maybe storing keybinds in a Map?\n     */\n    skipKeybind: { key: \"Enter\" },\n    skipToHighlightKeybind: { key: \"Enter\", ctrl: true },\n    startSponsorKeybind: { key: \";\" },\n    submitKeybind: { key: \"'\" },\n    actuallySubmitKeybind: { key: \"'\", ctrl: true },\n    previewKeybind: { key: \";\", ctrl: true },\n    nextChapterKeybind: { key: \"ArrowRight\", ctrl: true },\n    previousChapterKeybind: { key: \"ArrowLeft\", ctrl: true },\n    closeSkipNoticeKeybind: { key: \"Backspace\" },\n    downvoteKeybind: { key: \"h\", shift: true },\n    upvoteKeybind: { key: \"g\", shift: true },\n\n    categorySelections: [{\n        name: \"sponsor\" as Category,\n        option: CategorySkipOption.AutoSkip\n    }, {\n        name: \"poi_highlight\" as Category,\n        option: CategorySkipOption.ManualSkip\n    }, {\n        name: \"exclusive_access\" as Category,\n        option: CategorySkipOption.ShowOverlay\n    }, {\n        name: \"chapter\" as Category,\n        option: CategorySkipOption.ShowOverlay\n    }],\n\n    payments: {\n        licenseKey: null,\n        lastCheck: 0,\n        lastFreeCheck: 0,\n        freeAccess: false,\n        chaptersAllowed: false\n    },\n\n    colorPalette: {\n        red: \"#780303\",\n        white: \"#ffffff\",\n        locked: \"#ffc83d\"\n    },\n\n    // Preview bar\n    barTypes: {\n        \"preview-chooseACategory\": {\n            color: \"#ffffff\",\n            opacity: \"0.7\"\n        },\n        \"sponsor\": {\n            color: \"#00d400\",\n            opacity: \"0.7\"\n        },\n        \"preview-sponsor\": {\n            color: \"#007800\",\n            opacity: \"0.7\"\n        },\n        \"selfpromo\": {\n            color: \"#ffff00\",\n            opacity: \"0.7\"\n        },\n        \"preview-selfpromo\": {\n            color: \"#bfbf35\",\n            opacity: \"0.7\"\n        },\n        \"exclusive_access\": {\n            color: \"#008a5c\",\n            opacity: \"0.7\"\n        },\n        \"interaction\": {\n            color: \"#cc00ff\",\n            opacity: \"0.7\"\n        },\n        \"preview-interaction\": {\n            color: \"#6c0087\",\n            opacity: \"0.7\"\n        },\n        \"intro\": {\n            color: \"#00ffff\",\n            opacity: \"0.7\"\n        },\n        \"preview-intro\": {\n            color: \"#008080\",\n            opacity: \"0.7\"\n        },\n        \"outro\": {\n            color: \"#0202ed\",\n            opacity: \"0.7\"\n        },\n        \"preview-outro\": {\n            color: \"#000070\",\n            opacity: \"0.7\"\n        },\n        \"preview\": {\n            color: \"#008fd6\",\n            opacity: \"0.7\"\n        },\n        \"preview-preview\": {\n            color: \"#005799\",\n            opacity: \"0.7\"\n        },\n        \"hook\": {\n            color: \"#395699\",\n            opacity: \"0.8\"\n        },\n        \"preview-hook\": {\n            color: \"#273963\",\n            opacity: \"0.7\"\n        },\n        \"music_offtopic\": {\n            color: \"#ff9900\",\n            opacity: \"0.7\"\n        },\n        \"preview-music_offtopic\": {\n            color: \"#a6634a\",\n            opacity: \"0.7\"\n        },\n        \"poi_highlight\": {\n            color: \"#ff1684\",\n            opacity: \"0.7\"\n        },\n        \"preview-poi_highlight\": {\n            color: \"#9b044c\",\n            opacity: \"0.7\"\n        },\n        \"filler\": {\n            color: \"#7300FF\",\n            opacity: \"0.9\"\n        },\n        \"preview-filler\": {\n            color: \"#2E0066\",\n            opacity: \"0.7\"\n        },\n        \"chapter\": {\n            color: \"#ffd983\",\n            opacity: \"0\"\n        },\n    }\n};\n\nconst localDefaults = {\n    downvotedSegments: {},\n    navigationApiAvailable: null,\n    alreadyInstalled: false,\n\n    unsubmittedSegments: {},\n    skipRules: [],\n\n    channelSkipProfileIDs: {},\n    skipProfiles: {},\n    skipProfileTemp: null\n};\n\nconst Config = new ConfigClass(syncDefaults, localDefaults, migrateOldSyncFormats);\nexport default Config;\n\nexport function generateDebugDetails(): string {\n    // Build output debug information object\n    const output = {\n        debug: {\n            userAgent: navigator.userAgent,\n            platform: navigator.platform,\n            language: navigator.language,\n            extensionVersion: chrome.runtime.getManifest().version\n        },\n        config: JSON.parse(JSON.stringify(Config.cachedSyncConfig)) // Deep clone config object\n    };\n\n    // Sanitise sensitive user config values\n    delete output.config.userID;\n    output.config.serverAddress = (output.config.serverAddress === CompileConfig.serverAddress)\n        ? \"Default server address\" : \"Custom server address\";\n    output.config.invidiousInstances = output.config.invidiousInstances.length;\n    output.config.skipRules = output.config.skipRules.length;\n\n    return JSON.stringify(output, null, 4);\n}\n","import SubmissionNotice from \"./render/SubmissionNotice\";\nimport SkipNoticeComponent from \"./components/SkipNoticeComponent\";\nimport SkipNotice from \"./render/SkipNotice\";\n\nexport interface ContentContainer {\n    (): {\n        vote: (type: number, UUID: SegmentUUID, category?: Category, skipNotice?: SkipNoticeComponent) => void;\n        dontShowNoticeAgain: () => void;\n        unskipSponsorTime: (segment: SponsorTime, unskipTime: number, forceSeek?: boolean, voteNotice?: boolean) => void;\n        sponsorTimes: SponsorTime[];\n        sponsorTimesSubmitting: SponsorTime[];\n        skipNotices: SkipNotice[];\n        sponsorVideoID;\n        reskipSponsorTime: (segment: SponsorTime, forceSeek?: boolean) => void;\n        updatePreviewBar: () => void;\n        onMobileYouTube: boolean;\n        sponsorSubmissionNotice: SubmissionNotice;\n        resetSponsorSubmissionNotice: (callRef?: boolean) => void;\n        updateEditButtonsOnPlayer: () => void;\n        previewTime: (time: number, unpause?: boolean) => void;\n        videoInfo: VideoInfo;\n        getRealCurrentTime: () => number;\n        lockedCategories: string[];\n        channelIDInfo: ChannelIDInfo;\n    };\n}\n\nexport interface VideoDurationResponse {\n    duration: number;\n}\n\nexport enum CategorySkipOption {\n    FallbackToDefault = -2,\n    Disabled = -1,\n    ShowOverlay,\n    ManualSkip,\n    AutoSkip\n}\n\nexport interface CategorySelection {\n    name: Category;\n    option: CategorySkipOption;\n}\n\nexport enum SponsorHideType {\n    Visible = undefined,\n    Downvoted = 1,\n    MinimumDuration,\n    Hidden,\n}\n\nexport enum ActionType {\n    Skip = \"skip\",\n    Mute = \"mute\",\n    Chapter = \"chapter\",\n    Full = \"full\",\n    Poi = \"poi\"\n}\n\nexport const ActionTypes = [\n    ActionType.Skip,\n    ActionType.Mute,\n    ActionType.Chapter,\n    ActionType.Full,\n    ActionType.Poi\n];\n\nexport type SegmentUUID = string  & { __segmentUUIDBrand: unknown };\nexport type Category = string & { __categoryBrand: unknown };\n\nexport enum SponsorSourceType {\n    Server = undefined,\n    Local = 1,\n    YouTube = 2,\n    Autogenerated = 3\n}\n\nexport interface SegmentContainer {\n    segment: [number] | [number, number];\n}\n\nexport interface SponsorTime extends SegmentContainer {\n    UUID: SegmentUUID;\n    locked?: number;\n\n    category: Category;\n    actionType: ActionType;\n    description?: string;\n\n    hidden?: SponsorHideType;\n    source: SponsorSourceType;\n    videoDuration?: number;\n}\n\nexport interface ScheduledTime extends SponsorTime {\n    scheduledTime: number;\n}\n\nexport interface PreviewBarOption {\n    color: string;\n    opacity: string;\n}\n\n\nexport interface Registration {\n    message: string;\n    id: string;\n    allFrames: boolean;\n    js: string[];\n    css: string[];\n    matches: string[];\n}\n\nexport interface BackgroundScriptContainer {\n    registerFirefoxContentScript: (opts: Registration) => void;\n    unregisterFirefoxContentScript: (id: string) => void;\n}\n\nexport interface VideoInfo {\n    responseContext: {\n        serviceTrackingParams: Array<{service: string; params: Array<{key: string; value: string}>}>;\n        webResponseContextExtensionData: {\n            hasDecorated: boolean;\n        };\n    };\n    playabilityStatus: {\n        status: string;\n        playableInEmbed: boolean;\n        miniplayer: {\n            miniplayerRenderer: {\n                playbackMode: string;\n            };\n        };\n    };\n    streamingData: unknown;\n    playbackTracking: unknown;\n    videoDetails: {\n        videoId: string;\n        title: string;\n        lengthSeconds: string;\n        keywords: string[];\n        channelId: string;\n        isOwnerViewing: boolean;\n        shortDescription: string;\n        isCrawlable: boolean;\n        thumbnail: {\n            thumbnails: Array<{url: string; width: number; height: number}>;\n        };\n        averageRating: number;\n        allowRatings: boolean;\n        viewCount: string;\n        author: string;\n        isPrivate: boolean;\n        isUnpluggedCorpus: boolean;\n        isLiveContent: boolean;\n    };\n    playerConfig: unknown;\n    storyboards: unknown;\n    microformat: {\n        playerMicroformatRenderer: {\n            thumbnail: {\n                thumbnails: Array<{url: string; width: number; height: number}>;\n            };\n            embed: {\n                iframeUrl: string;\n                flashUrl: string;\n                width: number;\n                height: number;\n                flashSecureUrl: string;\n            };\n            title: {\n                simpleText: string;\n            };\n            description: {\n                simpleText: string;\n            };\n            lengthSeconds: string;\n            ownerProfileUrl: string;\n            externalChannelId: string;\n            availableCountries: string[];\n            isUnlisted: boolean;\n            hasYpcMetadata: boolean;\n            viewCount: string;\n            category: Category;\n            publishDate: string;\n            ownerChannelName: string;\n            uploadDate: string;\n        };\n    };\n    trackingParams: string;\n    attestation: unknown;\n    messages: unknown;\n}\n\nexport type VideoID = string;\n\nexport type UnEncodedSegmentTimes = [string, SponsorTime[]][];\n\nexport enum ChannelIDStatus {\n    Fetching,\n    Found,\n    Failed\n}\n\nexport interface ChannelIDInfo {\n    id: string;\n    status: ChannelIDStatus;\n}\n\nexport interface SkipToTimeParams {\n    v: HTMLVideoElement; \n    skipTime: number[]; \n    skippingSegments: SponsorTime[]; \n    openNotice: boolean; \n    forceAutoSkip?: boolean;\n    unskipTime?: number;\n}\n\nexport interface ToggleSkippable {\n    toggleSkip: () => void;\n    setShowKeybindHint: (show: boolean) => void;\n}\n\nexport enum NoticeVisibilityMode {\n    FullSize = 0,\n    MiniForAutoSkip = 1,\n    MiniForAll = 2,\n    FadedForAutoSkip = 3,\n    FadedForAll = 4\n}\n\nexport enum SegmentListDefaultTab {\n    Segments,\n    Chapters,\n}","import Config, { VideoDownvotes } from \"./config\";\nimport { SponsorTime, BackgroundScriptContainer, Registration, VideoID, SponsorHideType } from \"./types\";\n\nimport { getHash, HashedValue } from \"../maze-utils/src/hash\";\nimport { waitFor } from \"../maze-utils/src\";\nimport { findValidElementFromSelector } from \"../maze-utils/src/dom\";\nimport { isSafari } from \"../maze-utils/src/config\";\nimport { asyncRequestToServer } from \"./utils/requests\";\nimport { FetchResponse, logRequest } from \"../maze-utils/src/background-request-proxy\";\nimport { formatJSErrorMessage, getLongErrorMessage } from \"../maze-utils/src/formating\";\n\nexport default class Utils {\n    \n    // Contains functions needed from the background script\n    backgroundScriptContainer: BackgroundScriptContainer | null;\n\n    // Used to add content scripts and CSS required\n    js = [\n        \"./js/content.js\"\n    ];\n    css = [\n        \"content.css\",\n        \"./libs/Source+Sans+Pro.css\",\n        \"popup.css\",\n        \"shared.css\"\n    ];\n\n    constructor(backgroundScriptContainer: BackgroundScriptContainer = null) {\n        this.backgroundScriptContainer = backgroundScriptContainer;\n    }\n\n    async wait<T>(condition: () => T, timeout = 5000, check = 100): Promise<T> {\n        return waitFor(condition, timeout, check);\n    }\n\n    containsPermission(permissions: chrome.permissions.Permissions): Promise<boolean> {\n        return new Promise((resolve) => {\n            chrome.permissions.contains(permissions, resolve)\n        });\n    }\n\n    /**\n     * Asks for the optional permissions required for all extra sites.\n     * It also starts the content script registrations.\n     * \n     * For now, it is just SB.config.invidiousInstances.\n     * \n     * @param {CallableFunction} callback\n     */\n    setupExtraSitePermissions(callback: (granted: boolean) => void): void {\n        const permissions = [];\n        if (isSafari()) {\n            permissions.push(\"webNavigation\");\n        }\n\n        chrome.permissions.request({\n            origins: this.getPermissionRegex(),\n            permissions: permissions\n        }, async (granted) => {\n            if (granted) {\n                this.setupExtraSiteContentScripts();\n            } else {\n                this.removeExtraSiteRegistration();\n            }\n\n            callback(granted);\n        });\n    }\n\n    getExtraSiteRegistration(): Registration {\n        return {\n            message: \"registerContentScript\",\n            id: \"invidious\",\n            allFrames: true,\n            js: this.js,\n            css: this.css,\n            matches: this.getPermissionRegex()\n        };\n    }\n\n    /**\n     * Registers the content scripts for the extra sites.\n     * Will use a different method depending on the browser.\n     * This is called by setupExtraSitePermissions().\n     * \n     * For now, it is just SB.config.invidiousInstances.\n     */\n    setupExtraSiteContentScripts(): void {\n        const registration = this.getExtraSiteRegistration();\n\n        if (this.backgroundScriptContainer) {\n            this.backgroundScriptContainer.registerFirefoxContentScript(registration);\n        } else {\n            chrome.runtime.sendMessage(registration);\n        }\n    }\n\n    /**\n     * Removes the permission and content script registration.\n     */\n    removeExtraSiteRegistration(): void {\n        const id = \"invidious\";\n\n        if (this.backgroundScriptContainer) {\n            this.backgroundScriptContainer.unregisterFirefoxContentScript(id);\n        } else {\n            chrome.runtime.sendMessage({\n                message: \"unregisterContentScript\",\n                id: id\n            });\n        }\n\n        chrome.permissions.remove({\n            origins: this.getPermissionRegex()\n        });\n    }\n\n    applyInvidiousPermissions(enable: boolean, option = \"supportInvidious\"): Promise<boolean> {\n        return new Promise((resolve) => {\n            if (enable) {\n                this.setupExtraSitePermissions((granted) => {\n                    if (!granted) {\n                        Config.config[option] = false;\n                    }\n\n                    resolve(granted);\n                });\n            } else {\n                this.removeExtraSiteRegistration();\n                resolve(false);\n            }\n        });\n    }\n\n    containsInvidiousPermission(): Promise<boolean> {\n        return new Promise((resolve) => {\n            const permissions = [];\n            if (isSafari()) {\n                permissions.push(\"webNavigation\");\n            }\n\n            chrome.permissions.contains({\n                origins: this.getPermissionRegex(),\n                permissions: permissions\n            }, function (result) {\n                resolve(result);\n            });\n        })\n    }\n\n    /**\n     * Merges any overlapping timestamp ranges into single segments and returns them as a new array.\n     */\n    getMergedTimestamps(timestamps: number[][]): [number, number][] {\n        let deduped: [number, number][] = [];\n\n        // Cases ([] = another segment, <> = current range):\n        // [<]>, <[>], <[]>, [<>], [<][>]\n        timestamps.forEach((range) => {\n            // Find segments the current range overlaps\n            const startOverlaps = deduped.findIndex((other) => range[0] >= other[0] && range[0] <= other[1]);\n            const endOverlaps = deduped.findIndex((other) => range[1] >= other[0] && range[1] <= other[1]);\n\n            if (~startOverlaps && ~endOverlaps) {\n                // [<][>] Both the start and end of this range overlap another segment\n                // [<>] This range is already entirely contained within an existing segment\n                if (startOverlaps === endOverlaps) return;\n\n                // Remove the range with the higher index first to avoid the index shifting\n                const other1 = deduped.splice(Math.max(startOverlaps, endOverlaps), 1)[0];\n                const other2 = deduped.splice(Math.min(startOverlaps, endOverlaps), 1)[0];\n\n                // Insert a new segment spanning the start and end of the range\n                deduped.push([Math.min(other1[0], other2[0]), Math.max(other1[1], other2[1])]);\n            } else if (~startOverlaps) {\n                // [<]> The start of this range overlaps another segment, extend its end\n                deduped[startOverlaps][1] = range[1];\n            } else if (~endOverlaps) {\n                // <[>] The end of this range overlaps another segment, extend its beginning\n                deduped[endOverlaps][0] = range[0];\n            } else {\n                // No overlaps, just push in a copy\n                deduped.push(range.slice() as [number, number]);\n            }\n\n            // <[]> Remove other segments contained within this range\n            deduped = deduped.filter((other) => !(other[0] > range[0] && other[1] < range[1]));\n        });\n\n        return deduped;\n    }\n\n    /**\n     * Returns the total duration of the timestamps, taking into account overlaps.\n     */\n    getTimestampsDuration(timestamps: number[][]): number {\n        return this.getMergedTimestamps(timestamps).reduce((acc, range) => {\n            return acc + range[1] - range[0];\n        }, 0);\n    }\n\n    getSponsorIndexFromUUID(sponsorTimes: SponsorTime[], UUID: string): number {\n        for (let i = 0; i < sponsorTimes.length; i++) {\n            if (sponsorTimes[i].UUID && (sponsorTimes[i].UUID.startsWith(UUID) || UUID.startsWith(sponsorTimes[i].UUID))) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    getSponsorTimeFromUUID(sponsorTimes: SponsorTime[], UUID: string): SponsorTime {\n        return sponsorTimes[this.getSponsorIndexFromUUID(sponsorTimes, UUID)];\n    }\n\n    /**\n     * @returns {String[]} Domains in regex form\n     */\n    getPermissionRegex(domains: string[] = []): string[] {\n        const permissionRegex: string[] = [];\n        if (domains.length === 0) {\n            domains = [...Config.config.invidiousInstances];\n        }\n\n        for (const url of domains) {\n            permissionRegex.push(\"https://*.\" + url + \"/*\");\n            permissionRegex.push(\"http://*.\" + url + \"/*\");\n        }\n\n        return permissionRegex;\n    }\n\n    findReferenceNode(): HTMLElement {\n        const selectors = [\n            \"#player-container-id\", // Mobile YouTube\n            \"#movie_player\",\n            \".html5-video-player\", // May 2023 Card-Based YouTube Layout\n            \"#c4-player\", // Channel Trailer\n            \"#player-container\", // Preview on hover\n            \"#main-panel.ytmusic-player-page\", // YouTube music\n            \"#player-container .video-js\", // Invidious\n            \".main-video-section > .video-container\", // Cloudtube\n            \".shaka-video-container\", // Piped\n            \"#player-container.ytk-player\", // YT Kids\n            \"#id-tv-container\" // YTTV\n        ];\n\n        let referenceNode = findValidElementFromSelector(selectors)\n        if (referenceNode == null) {\n            //for embeds\n            const player = document.getElementById(\"player\");\n            referenceNode = player?.firstChild as HTMLElement;\n            if (referenceNode) {\n                let index = 1;\n\n                //find the child that is the video player (sometimes it is not the first)\n                while (index < player.children.length && (!referenceNode.classList?.contains(\"html5-video-player\") || !referenceNode.classList?.contains(\"ytp-embed\"))) {\n                    referenceNode = player.children[index] as HTMLElement;\n\n                    index++;\n                }\n            }\n        }\n\n        return referenceNode;\n    }\n\n    isContentScript(): boolean {\n        return window.location.protocol === \"http:\" || window.location.protocol === \"https:\";\n    }\n\n    isHex(num: string): boolean {\n        return Boolean(num.match(/^[0-9a-f]+$/i));\n    }\n\n    async addHiddenSegment(videoID: VideoID, segmentUUID: string, hidden: SponsorHideType) {\n        if ((chrome.extension.inIncognitoContext && !Config.config.trackDownvotesInPrivate)\n                || !Config.config.trackDownvotes) return;\n\n        if (segmentUUID.length < 60) {\n            let segmentIDData: FetchResponse;\n            try {\n                segmentIDData = await asyncRequestToServer(\"GET\", \"/api/segmentID\", {\n                    UUID: segmentUUID,\n                    videoID\n                });\n            } catch (e) {\n                console.error(\"[SB] Caught error while trying to resolve the segment UUID to be hidden\", e);\n                alert(`${chrome.i18n.getMessage(\"segmentHideFailed\")}\\n${formatJSErrorMessage(e)}`);\n                return;\n            }\n\n            if (segmentIDData.ok && segmentIDData.responseText) {\n                segmentUUID = segmentIDData.responseText;\n            } else {\n                logRequest(segmentIDData, \"SB\", \"segment UUID resolution\");\n                alert(`${chrome.i18n.getMessage(\"segmentHideFailed\")}\\n${getLongErrorMessage(segmentIDData.status, segmentIDData.responseText)}`);\n                return;\n            }\n        }\n\n        const hashedVideoID = (await getHash(videoID, 1)).slice(0, 4) as VideoID & HashedValue;\n        const UUIDHash = await getHash(segmentUUID, 1);\n\n        const allDownvotes = Config.local.downvotedSegments;\n        const currentVideoData = allDownvotes[hashedVideoID] || { segments: [], lastAccess: 0 };\n\n        currentVideoData.lastAccess = Date.now();\n        const existingData = currentVideoData.segments.find((segment) => segment.uuid === UUIDHash);\n        if (hidden === SponsorHideType.Visible) {\n            currentVideoData.segments.splice(currentVideoData.segments.indexOf(existingData), 1);\n\n            if (currentVideoData.segments.length === 0) {\n                delete allDownvotes[hashedVideoID];\n            }\n        } else {\n            if (existingData) {\n                existingData.hidden = hidden;\n            } else {\n                currentVideoData.segments.push({\n                    uuid: UUIDHash,\n                    hidden\n                });\n            }\n\n            allDownvotes[hashedVideoID] = currentVideoData;\n        }\n\n        const entries = Object.entries(allDownvotes);\n        if (entries.length > 10000) {\n            let min: [string, VideoDownvotes] = null;\n            for (let i = 0; i < entries[0].length; i++) {\n                if (min === null || entries[i][1].lastAccess < min[1].lastAccess) {\n                    min = entries[i];\n                }\n            }\n\n            delete allDownvotes[min[0]];\n        }\n\n        Config.forceLocalUpdate(\"downvotedSegments\");\n    }\n}\n","import * as CompileConfig from \"../../config.json\";\n\nimport Config from \"../config\";\nimport { isSafari } from \"../../maze-utils/src/config\";\nimport { isFirefoxOrSafari } from \"../../maze-utils/src\";\n\nexport function isDeArrowInstalled(): Promise<boolean> {\n    if (Config.config.deArrowInstalled) {\n        return Promise.resolve(true);\n    } else {\n        return new Promise((resolve) => {\n            const extensionIds = getExtensionIdsToImportFrom();\n\n            let count = 0;\n            for (const id of extensionIds) {\n                chrome.runtime.sendMessage(id, { message: \"isInstalled\" }, (response) => {\n                    if (chrome.runtime.lastError) {\n                        count++;\n\n                        if (count === extensionIds.length) {\n                            resolve(false);\n                        }\n                        return;\n                    }\n\n                    resolve(response);\n                    if (response) {\n                        Config.config.deArrowInstalled = true;\n                    }\n                });\n            }\n        });\n    }\n}\n\nexport function getExtensionIdsToImportFrom(): string[] {\n    if (isSafari()) {\n        return CompileConfig.extensionImportList.safari;\n    } else if (isFirefoxOrSafari()) {\n        return CompileConfig.extensionImportList.firefox;\n    } else {\n        return CompileConfig.extensionImportList.chromium;\n    }\n}","if (typeof (window) !== \"undefined\") {\n    window[\"SBLogs\"] = {\n        debug: [],\n        warn: []\n    };\n}\n\nexport function logDebug(message: string) {\n    if (typeof (window) !== \"undefined\") {\n        window[\"SBLogs\"].debug.push(`[${new Date().toISOString()}] ${message}`);\n    } else {\n        console.log(`[${new Date().toISOString()}] ${message}`)\n    }\n}\n\nexport function logWarn(message: string) {\n    if (typeof (window) !== \"undefined\") {\n        window[\"SBLogs\"].warn.push(`[${new Date().toISOString()}] ${message}`);\n    } else {\n        console.warn(`[${new Date().toISOString()}] ${message}`)\n    }\n}","import Config from \"../config\";\nimport * as CompileConfig from \"../../config.json\";\nimport { FetchResponse, sendRequestToCustomServer } from \"../../maze-utils/src/background-request-proxy\";\n\n/**\n * Sends a request to the SponsorBlock server with address added as a query\n * \n * @param type The request type. \"GET\", \"POST\", etc.\n * @param address The address to add to the SponsorBlock server address\n * @param callback \n */    \nexport async function asyncRequestToServer(type: string, address: string, data = {}, headers = {}): Promise<FetchResponse> {\n    const serverAddress = Config.config.testingServer ? CompileConfig.testingServerAddress : Config.config.serverAddress;\n\n    return await (sendRequestToCustomServer(type, serverAddress + address, data, headers));\n}\n","import type { CategorySkipOption } from \"../types\";\n\nexport interface Permission {\n    canSubmit: boolean;\n}\n\n// Note that attributes that are prefixes of other attributes (like `time.start`) need to be ordered *after*\n// the longer attributes, because these are matched sequentially. Using the longer attribute would otherwise result\n// in an error token.\nexport enum SkipRuleAttribute {\n    StartTimePercent = \"time.startPercent\",\n    StartTime = \"time.start\",\n    EndTimePercent = \"time.endPercent\",\n    EndTime = \"time.end\",\n    DurationPercent = \"time.durationPercent\",\n    Duration = \"time.duration\",\n    Category = \"category\",\n    ActionType = \"actionType\",\n    Description = \"chapter.name\",\n    Source = \"chapter.source\",\n    ChannelID = \"channel.id\",\n    ChannelName = \"channel.name\",\n    VideoDuration = \"video.duration\",\n    Title = \"video.title\"\n}\n\n// Note that operators that are prefixes of other attributes (like `<`) need to be ordered *after* the longer\n// operators, because these are matched sequentially. Using the longer operator would otherwise result\n// in an error token.\nexport enum SkipRuleOperator {\n    LessOrEqual = \"<=\",\n    Less = \"<\",\n    GreaterOrEqual = \">=\",\n    Greater = \">\",\n    NotEqual = \"!=\",\n    Equal = \"==\",\n    NotContains = \"!*=\",\n    Contains = \"*=\",\n    NotRegex = \"!~=\",\n    Regex = \"~=\",\n    NotRegexIgnoreCase = \"!~i=\",\n    RegexIgnoreCase = \"~i=\"\n}\n\nexport interface AdvancedSkipCheck {\n    kind: \"check\";\n    attribute: SkipRuleAttribute;\n    operator: SkipRuleOperator;\n    value: string | number;\n}\n\nexport enum PredicateOperator {\n    And = \"and\",\n    Or = \"or\",\n}\n\nexport interface AdvancedSkipOperator {\n    kind: \"operator\";\n    operator: PredicateOperator;\n    left: AdvancedSkipPredicate;\n    right: AdvancedSkipPredicate;\n    displayInverted?: boolean;\n}\n\nexport type AdvancedSkipPredicate = AdvancedSkipCheck | AdvancedSkipOperator;\n\nexport interface AdvancedSkipRule {\n    predicate: AdvancedSkipPredicate;\n    skipOption: CategorySkipOption;\n    comments: string[];\n}","function NestedProxy(target) {\n\treturn new Proxy(target, {\n\t\tget(target, prop) {\n\t\t\tif (!target[prop]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof target[prop] !== 'function') {\n\t\t\t\treturn new NestedProxy(target[prop]);\n\t\t\t}\n\n\t\t\treturn (...arguments_) =>\n\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\ttarget[prop](...arguments_, result => {\n\t\t\t\t\t\tif (chrome.runtime.lastError) {\n\t\t\t\t\t\t\treject(new Error(chrome.runtime.lastError.message));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t},\n\t});\n}\n\nconst chromeP = globalThis.chrome && new NestedProxy(globalThis.chrome);\n\nexport default chromeP;\n","import escapeStringRegexp from 'escape-string-regexp';\n// Copied from https://github.com/mozilla/gecko-dev/blob/073cc24f53d0cf31403121d768812146e597cc9d/toolkit/components/extensions/schemas/manifest.json#L487-L491\nexport const patternValidationRegex = /^(https?|wss?|file|ftp|\\*):\\/\\/(\\*|\\*\\.[^*/]+|[^*/]+)\\/.*$|^file:\\/\\/\\/.*$|^resource:\\/\\/(\\*|\\*\\.[^*/]+|[^*/]+)\\/.*$|^about:/;\nconst isFirefox = typeof navigator === 'object' && navigator.userAgent.includes('Firefox/');\nexport const allStarsRegex = isFirefox\n    ? /^(https?|wss?):[/][/][^/]+([/].*)?$/\n    : /^https?:[/][/][^/]+([/].*)?$/;\nexport const allUrlsRegex = /^(https?|file|ftp):[/]+/;\nfunction getRawPatternRegex(matchPattern) {\n    if (!patternValidationRegex.test(matchPattern)) {\n        throw new Error(matchPattern + ' is an invalid pattern, it must match ' + String(patternValidationRegex));\n    }\n    let [, protocol, host, pathname] = matchPattern.split(/(^[^:]+:[/][/])([^/]+)?/);\n    protocol = protocol\n        .replace('*', isFirefox ? '(https?|wss?)' : 'https?') // Protocol wildcard\n        .replace(/[/]/g, '[/]'); // Escape slashes\n    host = (host !== null && host !== void 0 ? host : '') // Undefined for file:///\n        .replace(/^[*][.]/, '([^/]+.)*') // Initial wildcard\n        .replace(/^[*]$/, '[^/]+') // Only wildcard\n        .replace(/[.]/g, '[.]') // Escape dots\n        .replace(/[*]$/g, '[^.]+'); // Last wildcard\n    pathname = pathname\n        .replace(/[/]/g, '[/]') // Escape slashes\n        .replace(/[.]/g, '[.]') // Escape dots\n        .replace(/[*]/g, '.*'); // Any wildcard\n    return '^' + protocol + host + '(' + pathname + ')?$';\n}\nexport function patternToRegex(...matchPatterns) {\n    // No pattern, match nothing https://stackoverflow.com/q/14115522/288906\n    if (matchPatterns.length === 0) {\n        return /$./;\n    }\n    if (matchPatterns.includes('<all_urls>')) {\n        return allUrlsRegex;\n    }\n    if (matchPatterns.includes('*://*/*')) {\n        return allStarsRegex;\n    }\n    return new RegExp(matchPatterns.map(x => getRawPatternRegex(x)).join('|'));\n}\n// The parens are required by .split() to preserve the symbols\nconst globSymbols = /([?*]+)/;\nfunction splitReplace(part, index) {\n    if (part === '') {\n        // Shortcut for speed\n        return '';\n    }\n    if (index % 2 === 0) {\n        // Raw text, escape it\n        return escapeStringRegexp(part);\n    }\n    // Else: Symbol\n    if (part.includes('*')) { // Can be more than one and it swallows surrounding question marks\n        return '.*';\n    }\n    return [...part].map(() => isFirefox ? '.' : '.?').join('');\n}\nfunction getRawGlobRegex(glob) {\n    const regexString = glob\n        .split(globSymbols)\n        // eslint-disable-next-line unicorn/no-array-callback-reference -- tis ok \n        .map(splitReplace)\n        .join('');\n    // Drop \"start with anything\" and \"end with anything\" sequences because they're the default for regex\n    return ('^' + regexString + '$')\n        .replace(/^[.][*]/, '')\n        .replace(/[.][*]$/, '')\n        .replace(/^[$]$/, '.+'); // Catch `*` and `*`\n}\nexport function globToRegex(...globs) {\n    // No glob, match anything; `include_globs: []` is the default\n    if (globs.length === 0) {\n        return /.*/;\n    }\n    return new RegExp(globs.map(x => getRawGlobRegex(x)).join('|'));\n}\nexport function excludeDuplicatePatterns(matchPatterns) {\n    if (matchPatterns.includes('<all_urls>')) {\n        return ['<all_urls>'];\n    }\n    if (matchPatterns.includes('*://*/*')) {\n        return ['*://*/*'];\n    }\n    return matchPatterns.filter(possibleSubset => !matchPatterns.some(possibleSuperset => possibleSubset !== possibleSuperset && patternToRegex(possibleSuperset).test(possibleSubset)));\n}\n","import chromeP from 'webext-polyfill-kinda';\nimport { patternToRegex } from 'webext-patterns';\nconst gotScripting = Boolean(globalThis.chrome?.scripting);\nfunction castTarget(target) {\n    return typeof target === 'object' ? target : {\n        tabId: target,\n        frameId: 0,\n    };\n}\nfunction castAllFramesTarget(target) {\n    if (typeof target === 'object') {\n        return { ...target, allFrames: false };\n    }\n    return {\n        tabId: target,\n        frameId: undefined,\n        allFrames: true,\n    };\n}\nfunction castArray(possibleArray) {\n    if (Array.isArray(possibleArray)) {\n        return possibleArray;\n    }\n    return [possibleArray];\n}\nconst nativeFunction = /^function \\w+\\(\\) {[\\n\\s]+\\[native code][\\n\\s]+}/;\nexport async function executeFunction(target, function_, ...args) {\n    if (nativeFunction.test(String(function_))) {\n        throw new TypeError('Native functions need to be wrapped first, like `executeFunction(1, () => alert(1))`');\n    }\n    const { frameId, tabId } = castTarget(target);\n    if (gotScripting) {\n        const [injection] = await chrome.scripting.executeScript({\n            target: {\n                tabId,\n                frameIds: [frameId],\n            },\n            func: function_,\n            args,\n        });\n        return injection?.result;\n    }\n    const [result] = await chromeP.tabs.executeScript(tabId, {\n        code: `(${function_.toString()})(...${JSON.stringify(args)})`,\n        frameId,\n    });\n    return result;\n}\nfunction arrayOrUndefined(value) {\n    return value === undefined ? undefined : [value];\n}\n// eslint-disable-next-line @typescript-eslint/naming-convention -- It follows the native naming\nexport async function insertCSS({ tabId, frameId, files, allFrames, matchAboutBlank, runAt, }, { ignoreTargetErrors } = {}) {\n    const everyInsertion = Promise.all(files.map(async (content) => {\n        if (typeof content === 'string') {\n            content = { file: content };\n        }\n        if (gotScripting) {\n            return chrome.scripting.insertCSS({\n                target: {\n                    tabId,\n                    frameIds: arrayOrUndefined(frameId),\n                    allFrames: frameId === undefined ? allFrames : undefined,\n                },\n                files: 'file' in content ? [content.file] : undefined,\n                css: 'code' in content ? content.code : undefined,\n            });\n        }\n        return chromeP.tabs.insertCSS(tabId, {\n            ...content,\n            matchAboutBlank,\n            allFrames,\n            frameId,\n            runAt: runAt ?? 'document_start', // CSS should prefer `document_start` when unspecified\n        });\n    }));\n    if (ignoreTargetErrors) {\n        await catchTargetInjectionErrors(everyInsertion);\n    }\n    else {\n        await everyInsertion;\n    }\n}\nfunction assertNoCode(files) {\n    if (files.some(content => 'code' in content)) {\n        throw new Error('chrome.scripting does not support injecting strings of `code`');\n    }\n}\nexport async function executeScript({ tabId, frameId, files, allFrames, matchAboutBlank, runAt, }, { ignoreTargetErrors } = {}) {\n    const normalizedFiles = files.map(file => typeof file === 'string' ? { file } : file);\n    if (gotScripting) {\n        assertNoCode(normalizedFiles);\n        const injection = chrome.scripting.executeScript({\n            target: {\n                tabId,\n                frameIds: arrayOrUndefined(frameId),\n                allFrames: frameId === undefined ? allFrames : undefined,\n            },\n            files: normalizedFiles.map(({ file }) => file),\n        });\n        if (ignoreTargetErrors) {\n            await catchTargetInjectionErrors(injection);\n        }\n        else {\n            await injection;\n        }\n        // Don't return `injection`; the \"return value\" of a file is generally not useful\n        return;\n    }\n    // Don't use .map(), `code` injections can't be \"parallel\"\n    const executions = [];\n    for (const content of normalizedFiles) {\n        // Files are executed in order, but `code` isnt, so it must await the last script before injecting more\n        if ('code' in content) {\n            // eslint-disable-next-line no-await-in-loop -- On purpose, see above\n            await executions.at(-1);\n        }\n        executions.push(chromeP.tabs.executeScript(tabId, {\n            ...content,\n            matchAboutBlank,\n            allFrames,\n            frameId,\n            runAt,\n        }));\n    }\n    if (ignoreTargetErrors) {\n        await catchTargetInjectionErrors(Promise.all(executions));\n    }\n    else {\n        await Promise.all(executions);\n    }\n}\nexport async function getTabsByUrl(matches, excludeMatches) {\n    if (matches.length === 0) {\n        return [];\n    }\n    const exclude = excludeMatches ? patternToRegex(...excludeMatches) : undefined;\n    const tabs = await chromeP.tabs.query({ url: matches });\n    return tabs\n        .filter(tab => tab.id && tab.url && (exclude ? !exclude.test(tab.url) : true))\n        .map(tab => tab.id);\n}\nexport async function injectContentScript(where, scripts, options = {}) {\n    const targets = castArray(where);\n    await Promise.all(targets.map(async (target) => injectContentScriptInSpecificTarget(castAllFramesTarget(target), scripts, options)));\n}\nasync function injectContentScriptInSpecificTarget({ frameId, tabId, allFrames }, scripts, options = {}) {\n    const injections = castArray(scripts).flatMap(script => [\n        insertCSS({\n            tabId,\n            frameId,\n            allFrames,\n            files: script.css ?? [],\n            matchAboutBlank: script.matchAboutBlank ?? script.match_about_blank,\n            runAt: script.runAt ?? script.run_at,\n        }, options),\n        executeScript({\n            tabId,\n            frameId,\n            allFrames,\n            files: script.js ?? [],\n            matchAboutBlank: script.matchAboutBlank ?? script.match_about_blank,\n            runAt: script.runAt ?? script.run_at,\n        }, options),\n    ]);\n    await Promise.all(injections);\n}\n// Sourced from:\n// https://source.chromium.org/chromium/chromium/src/+/main:extensions/common/extension_urls.cc;drc=6b42116fe3b3d93a77750bdcc07948e98a728405;l=29\n// https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts\nconst blockedPrefixes = [\n    'chrome.google.com/webstore',\n    'accounts-static.cdn.mozilla.net',\n    'accounts.firefox.com',\n    'addons.cdn.mozilla.net',\n    'addons.mozilla.org',\n    'api.accounts.firefox.com',\n    'content.cdn.mozilla.net',\n    'discovery.addons.mozilla.org',\n    'input.mozilla.org',\n    'install.mozilla.org',\n    'oauth.accounts.firefox.com',\n    'profile.accounts.firefox.com',\n    'support.mozilla.org',\n    'sync.services.mozilla.com',\n    'testpilot.firefox.com',\n];\nexport function isScriptableUrl(url) {\n    if (!url.startsWith('http')) {\n        return false;\n    }\n    const cleanUrl = url.replace(/^https?:\\/\\//, '');\n    return blockedPrefixes.every(blocked => !cleanUrl.startsWith(blocked));\n}\nconst targetErrors = /^No frame with id \\d+ in tab \\d+.$|^No tab with id: \\d+.$|^The tab was closed.$|^The frame was removed.$/;\nasync function catchTargetInjectionErrors(promise) {\n    try {\n        await promise;\n    }\n    catch (error) {\n        // @ts-expect-error Optional chaining is good enough\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        if (!targetErrors.test(error?.message)) {\n            throw error;\n        }\n    }\n}\n","import { injectContentScript } from 'webext-content-scripts';\nimport chromeP from 'webext-polyfill-kinda';\nimport { patternToRegex } from 'webext-patterns';\nconst noMatchesError = 'Type error for parameter contentScriptOptions (Error processing matches: Array requires at least 1 items; you have 0) for contentScripts.register.';\nconst noPermissionError = 'Permission denied to register a content script for ';\nconst gotNavigation = typeof chrome === 'object' && 'webNavigation' in chrome;\nasync function isOriginPermitted(url) {\n    return chromeP.permissions.contains({\n        origins: [new URL(url).origin + '/*'],\n    });\n}\n// The callback is only used by webextension-polyfill\nexport default async function registerContentScript(contentScriptOptions, callback) {\n    const { js = [], css = [], matchAboutBlank, matches = [], excludeMatches, runAt, } = contentScriptOptions;\n    let { allFrames } = contentScriptOptions;\n    if (gotNavigation) {\n        allFrames = false;\n    }\n    else if (allFrames) {\n        console.warn('`allFrames: true` requires the `webNavigation` permission to work correctly: https://github.com/fregante/content-scripts-register-polyfill#permissions');\n    }\n    if (matches.length === 0) {\n        throw new Error(noMatchesError);\n    }\n    await Promise.all(matches.map(async (pattern) => {\n        if (!await chromeP.permissions.contains({ origins: [pattern] })) {\n            throw new Error(noPermissionError + pattern);\n        }\n    }));\n    const matchesRegex = patternToRegex(...matches);\n    const excludeMatchesRegex = patternToRegex(...excludeMatches !== null && excludeMatches !== void 0 ? excludeMatches : []);\n    const inject = async (url, tabId, frameId = 0) => {\n        if (!matchesRegex.test(url) // Manual `matches` glob matching\n            || excludeMatchesRegex.test(url) // Manual `exclude_matches` glob matching\n            || !await isOriginPermitted(url) // Without this, we might have temporary access via accessTab\n        ) {\n            return;\n        }\n        await injectContentScript({\n            tabId,\n            frameId,\n        }, {\n            css,\n            js,\n            matchAboutBlank,\n            runAt,\n        }, {\n            ignoreTargetErrors: true,\n        });\n    };\n    const tabListener = async (tabId, { status }, { url }) => {\n        // Only status updates are relevant\n        // No URL = no permission\n        if (status === 'loading' && url) {\n            void inject(url, tabId);\n        }\n    };\n    const navListener = async ({ tabId, frameId, url, }) => {\n        void inject(url, tabId, frameId);\n    };\n    if (gotNavigation) {\n        chrome.webNavigation.onCommitted.addListener(navListener);\n    }\n    else {\n        chrome.tabs.onUpdated.addListener(tabListener);\n    }\n    const registeredContentScript = {\n        async unregister() {\n            if (gotNavigation) {\n                chrome.webNavigation.onCommitted.removeListener(navListener);\n            }\n            else {\n                chrome.tabs.onUpdated.removeListener(tabListener);\n            }\n        },\n    };\n    if (typeof callback === 'function') {\n        callback(registeredContentScript);\n    }\n    return registeredContentScript;\n}\n","/// <reference path=\"./globals.d.ts\" />\n// The .js extension is required to create ESM-compatible file\nimport register from './ponyfill.js';\nif (typeof chrome === 'object' && !chrome.contentScripts) {\n    chrome.contentScripts = { register };\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(1398);\n"],"names":["sendRealRequestToCustomServer","type","url","data","headers","toLowerCase","objectToURI","fetch","method","redirect","body","JSON","stringify","isSerializable","value","window","structuredClone","serializeOrStringify","toString","String","chrome","runtime","onMessage","addListener","request","sender","callback","message","then","response","buffer","binary","isFirefoxOrSafari","isSafari","blob","Array","from","Uint8Array","arrayBuffer","responseText","text","responseBinary","returnHeaders","entries","reduce","acc","key","status","ok","catch","error","console","getHash","times","e","Promise","resolve","reject","sendMessage","prefix","requestDescription","isBodyGarbage","warn","chromeP","browser","cleanupListeners","getCleanupId","id","listener","push","source","started","performance","now","postMessage","addEventListener","extraScripts","ignoreNormalScipts","scripts","concat","getManifest","content_scripts","cs","tab","tabs","query","matches","css","length","scripting","insertCSS","target","tabId","files","executeScript","js","world","windows","getAll","populate","script","some","match","replace","file","navigator","vendor","formatKey","toUpperCase","constructor","syncDefaults","localDefaults","migrateOldSyncFormats","inDeArrow","configLocalListeners","configSyncListeners","cachedSyncConfig","cachedLocalStorage","config","local","this","setupConfig","result","sync","configProxy","storage","onChanged","changes","areaName","newValue","lastSet","nextToUpdate","Set","activeTimeout","self","syncHandler","set","obj","prop","Date","add","delayUpdate","items","clear","map","v","k","setTimeout","get","deleteProperty","remove","localHandler","Proxy","handler","forceSyncUpdate","forceLocalUpdate","lastError","alert","i18n","getMessage","fetchConfig","all","undefined","location","href","includes","addDefaults","Object","prototype","hasOwnProperty","call","key2","isReady","first","second","Boolean","alt","ctrl","shift","code","keybind","ret","isVisible","element","ignoreWidth","tagName","classList","contains","document","querySelectorAll","filter","duration","offsetHeight","offsetWidth","boundingRect","getBoundingClientRect","elementAtPoint","elementFromPoint","left","width","top","height","closest","isVisibleOrParent","checkParent","parentElement","findValidElement","elements","findValidElementFromGenerator","objects","generator","findPredicatedElement","selectors","predicate","selector","querySelector","textContent","trim","creatingWaitingMutationObserver","waitingMutationObserver","waitingElements","setupWaitingMutationListener","checkForObjects","mutations","foundSelectors","waitingElement","visibleCheck","callbacks","updatePossibleElements","found","mutation","addedNodes","HTMLElement","node","possibleElements","disconnect","MutationObserver","observe","documentElement","childList","subtree","getElement","initialElement","existingWaitingElement","find","startsWith","formatted","fragments","exec","parseInt","parseFloat","seconds","precise","Math","max","hours","floor","minutes","minutesDisplay","secondsNum","secondsDisplay","toFixed","isNaN","statusCode","errorMessage","introString","postFix","crypto","hashHex","i","hashBuffer","subtle","digest","TextEncoder","encode","b","padStart","join","condition","timeout","check","interval","intervalCheck","clearInterval","Error","stack","setInterval","includeQuestionMark","counter","seperator","encodeURIComponent","PromiseTimeoutError","promise","super","onFirefoxOrSafari","browser_specific_settings","onFirefox","gecko","cachedUserAgent","version","getLocalizedMessage","valNewH","v1","charset","cryptoFuncs","getRandomValues","values","Uint32Array","random","localizedTitle","title","localizedMessage","innerHTML","onTabUpdatedListener","onNavigationApiAvailableChange","navigationApiAvailable","onUpdated","removeListener","waitFor","utils","registerFirefoxContentScript","unregisterFirefoxContentScript","popupPort","contentScriptRegistrations","options","existingRegistrations","getRegisteredContentScripts","ids","every","registerContentScripts","runAt","allFrames","persistAcrossSessions","contentScripts","register","registration","unregisterContentScripts","unregister","wait","supportInvidious","setupExtraSiteContentScripts","setupBackgroundRequestProxy","setupTabUpdates","create","getURL","hash","UUID","category","videoID","userID","generateUserID","typeSection","address","serverAddress","testingServer","CompileConfig","testingServerAddress","asyncRequestToServer","submitVote","active","currentWindow","onMessageExternal","getExtensionIdsToImportFrom","allowExpirements","showDonationLink","showUpsells","darkMode","onConnect","port","name","onInstalled","alreadyInstalled","newUserID","categoryPillUpdate","containsInvidiousPermission","prideTheme","injectUpdatedScripts","logWarn","getExtraSiteRegistration","ConfigClass","ProtoConfig","resetToDefault","minutesSaved","skipCount","sponsorTimesContributed","Config","isVip","permissions","defaultCategory","segmentListDefaultTab","SegmentListDefaultTab","Segments","renderSegmentsAsChapters","forceChannelCheck","submissionCountSinceCategories","showTimeWithSkips","disableSkipping","muteSegments","fullVideoSegments","fullVideoLabelsOnThumbnails","manualSkipOnFullVideo","trackViewCount","trackViewCountInPrivate","trackDownvotes","trackDownvotesInPrivate","dontShowNotice","showUpcomingNotice","noticeVisibilityMode","NoticeVisibilityMode","FadedForAutoSkip","hideVideoPlayerControls","hideInfoButtonPlayerControls","hideDeleteButtonPlayerControls","hideUploadButtonPlayerControls","hideSkipButtonPlayerControls","hideDiscordLaunches","hideDiscordLink","invidiousInstances","minDuration","skipNoticeDuration","audioNotificationOnSkip","checkForUnlistedVideos","ytInfoPermissionGranted","showPopupDonationCount","showNewFeaturePopups","donateClicked","autoHideInfoButton","autoSkipOnMusicVideos","skipNonMusicOnlyOnYoutubeMusic","scrollToEditTimeUpdate","hookUpdate","showChapterInfoMessage","showCategoryGuidelines","showCategoryWithoutPermission","showSegmentNameInChapterBar","showAutogeneratedChapters","useVirtualTime","showSegmentFailedToFetchWarning","allowScrollingToEdit","deArrowInstalled","showDeArrowPromotion","showDeArrowInSettings","shownDeArrowPromotion","showZoomToFillError2","cleanPopup","hideSegmentCreationInPopup","categoryPillColors","skipKeybind","skipToHighlightKeybind","startSponsorKeybind","submitKeybind","actuallySubmitKeybind","previewKeybind","nextChapterKeybind","previousChapterKeybind","closeSkipNoticeKeybind","downvoteKeybind","upvoteKeybind","categorySelections","option","CategorySkipOption","AutoSkip","ManualSkip","ShowOverlay","payments","licenseKey","lastCheck","lastFreeCheck","freeAccess","chaptersAllowed","colorPalette","red","white","locked","barTypes","color","opacity","downvotedSegments","unsubmittedSegments","skipRules","channelSkipProfileIDs","skipProfiles","skipProfileTemp","output","rule","rules","kind","operator","PredicateOperator","And","right","comment","skipOption","comments","split","whitelistedChannels","skipProfileID","s","channelID","keys","selection","keybinds","j","keybindEquals","invidiousList","debug","userAgent","platform","language","extensionVersion","parse","ActionType","ChannelIDStatus","SponsorSourceType","SponsorHideType","ActionTypes","Skip","Mute","Chapter","Full","Poi","backgroundScriptContainer","containsPermission","setupExtraSitePermissions","origins","getPermissionRegex","granted","removeExtraSiteRegistration","applyInvidiousPermissions","enable","getMergedTimestamps","timestamps","deduped","forEach","range","startOverlaps","findIndex","other","endOverlaps","other1","splice","other2","min","slice","getTimestampsDuration","getSponsorIndexFromUUID","sponsorTimes","getSponsorTimeFromUUID","domains","permissionRegex","findReferenceNode","referenceNode","findValidElementFromSelector","player","getElementById","firstChild","index","children","isContentScript","protocol","isHex","num","addHiddenSegment","segmentUUID","hidden","extension","inIncognitoContext","segmentIDData","formatJSErrorMessage","logRequest","getLongErrorMessage","hashedVideoID","UUIDHash","allDownvotes","currentVideoData","segments","lastAccess","existingData","segment","uuid","Visible","indexOf","extensionImportList","safari","firefox","chromium","extensionIds","count","toISOString","log","sendRequestToCustomServer","SkipRuleOperator","SkipRuleAttribute","globalThis","NestedProxy","arguments_","patternValidationRegex","isFirefox","allStarsRegex","allUrlsRegex","matchPatterns","RegExp","x","matchPattern","test","host","pathname","getRawPatternRegex","gotScripting","castArray","possibleArray","isArray","arrayOrUndefined","async","frameId","matchAboutBlank","ignoreTargetErrors","everyInsertion","content","frameIds","catchTargetInjectionErrors","normalizedFiles","assertNoCode","injection","executions","at","targetErrors","gotNavigation","contentScriptOptions","excludeMatches","pattern","matchesRegex","excludeMatchesRegex","inject","URL","origin","isOriginPermitted","where","targets","injections","flatMap","match_about_blank","run_at","injectContentScriptInSpecificTarget","castAllFramesTarget","injectContentScript","tabListener","navListener","webNavigation","onCommitted","registeredContentScript","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__"],"sourceRoot":""}